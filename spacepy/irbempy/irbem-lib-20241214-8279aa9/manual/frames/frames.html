<!-- %***************************************************************************************************
% Copyright 2004-2008, S. Bourdarie
%
% This file is part of IRBEM-LIB.
%
%    IRBEM-LIB is free software: you can redistribute it and/or modify
%    it under the terms of the GNU Lesser General Public License as published by
%    the Free Software Foundation, either version 3 of the License, or
%    (at your option) any later version.
%
%    IRBEM-LIB is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU Lesser General Public License for more details.
%
%    You should have received a copy of the GNU Lesser General Public License
%    along with IRBEM-LIB.  If not, see <http://www.gnu.org/licenses/>.
% -->
<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
    <title>ONERA-DESP library - user's guide</title> 
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <meta content="Mozilla/4.72 [en] (X11; I; SunOS 5.8 sun4u) [Netscape]" name="GENERATOR" />
</head>
<body style="COLOR: black; BACKGROUND-COLOR: white" vlink="#00008b" link="#0000ff">

    <hr><a name="COMMON_ARGUMENTS"></a> 
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">Common Argument Definitions</font></font> 
    </h2>

    <font face="ARIAL, HELVETICA">Throughout the library, numerous
    input and output arguments retain the same meaning and
    format. This section provides the definitions for those
    arguments. The particular definitions given here are for the
    functions that perform a particular calculation for multiple
    points (ntime, up to NTIME_MAX, defined in
    IRBEM_GET_NTIME_MAX()). For a few functions, there is also a
    pitch-angle dimension given by Nipa, which is up to NALPHA_MAX =
    25.  For functions that can compute for only a single point or
    angle the NTIME_MAX argument can be ignored.  </font><br />
      <p>
    <font face="ARIAL, HELVETICA"><b>ntime:</b> long integer number of time in arrays
    (max allowed is NTIME_MAX)</font> 
    <p>
      <p>
    <font face="ARIAL, HELVETICA"><b>nipa:</b> long integer number of pitch angles in arrays
    (max allowed is NALPHA_MAX)</font> 
    <p>
        <font face="ARIAL, HELVETICA"><b>kext:</b> long integer to select external magnetic
        field</font> 
        <br />
    </p>
    <div style="MARGIN-LEFT: 40px; FONT-FAMILY: helvetica,arial,sans-serif">
        0&nbsp;&nbsp; = no external field 
        <br />
        1&nbsp;&nbsp; = Mead &amp; Fairfield [1975] (uses 0&#8804;Kp&#8804;9 - Valid for rGEO&#8804;17. Re)
        <br />
        2&nbsp;&nbsp; = Tsyganenko short [1987] (uses 0&#8804;Kp&#8804;9 - Valid for rGEO&#8804;30. Re) 
        <br />
        3&nbsp;&nbsp; = Tsyganenko long [1987] (uses 0&#8804;Kp&#8804;9 - Valid for rGEO&#8804;70. Re)
        <br />
        4&nbsp;&nbsp; = Tsyganenko [1989c] (uses 0&#8804;Kp&#8804;9 - Valid for rGEO&#8804;70. Re)
        <br />
        5&nbsp;&nbsp; = Olson &amp; Pfitzer quiet [1977] (default - Valid for rGEO&#8804;15. Re)
        <br />
        6&nbsp;&nbsp; = Olson &amp; Pfitzer dynamic [1988] (uses 5.&#8804;dens&#8804;50., 300.&#8804;velo&#8804;500., -100.&#8804;Dst&#8804;20. - Valid for rGEO&#8804;60. Re)
        <br />
        7&nbsp;&nbsp; = Tsyganenko [1996] (uses -100.&#8804;Dst (nT)&#8804;20., 0.5&#8804;Pdyn (nPa)&#8804;10.,
        |ByIMF| (nT)&#8804;10., |BzIMF| (nT)&#8804;10. - Valid for rGEO&#8804;40. Re) 
        <br />
        8&nbsp;&nbsp; = Ostapenko &amp; Maltsev [1997] (uses dst,Pdyn,BzIMF, Kp) 
        <br />
        9&nbsp;&nbsp; = Tsyganenko [2001] (uses -50.&#8804;Dst (nT)&#8804;20., 0.5&#8804;Pdyn (nPa)&#8804;5., 
        |ByIMF| (nT)&#8804;5., |BzIMF| (nT)&#8804;5., 0.&#8804;G1&#8804;10., 0.&#8804;G2&#8804;10. - Valid for xGSM&#8805;-15. Re) 
        <br />
        10 =Tsyganenko [2001] storm&nbsp; (uses Dst, Pdyn, ByIMF,
        BzIMF, G2, G3 - there is no upper or lower limit for those inputs - Valid for xGSM&#8805;-15. Re)
        <br />
        11 =Tsyganenko [2004] storm&nbsp; (uses Dst, Pdyn, ByIMF,
        BzIMF, W1, W2, W3, W4, W5, W6 - there is no upper or lower limit for those inputs - Valid for xGSM&#8805;-15. Re) 
        <br />
        12 =Alexeev [2000] - also known as Paraboloid model - Submitted to ISO&nbsp; (uses Dens, velo, Dst, BzIMF, AL) 
        <br />
        <br />
        <br />
        <span style="FONT-STYLE: italic">Notes: </span>
        <ol>
        <li>
            <span style="FONT-STYLE: italic">when the magnetic field
            model inputs are outside the allowed range bad data values are returned.</span>
        </li>
        <li>
            <span style="FONT-STYLE: italic">When solar wind inputs
            are required they must be taken in the vicinity of the day side magnetopause and not
            at L1.<br />
            </span>
        </li>
        </ol>
    </div>
    <p>
        <font face="ARIAL, HELVETICA"><b>
        <br />
        options: </b>array(5) of long integer to set some control options on computed values<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px; FONT-FAMILY: helvetica,arial,sans-serif">
        <ol>
            <li>
                <span style="FONT-WEIGHT: bold">options(1st element):</span>&nbsp; 0 - don't compute
                L* or &#934; ;&nbsp; 1 - compute L*; 2- compute &#934; 
                <br />
            </li>
            <li>
                <span style="FONT-WEIGHT: bold">options(2nd element): </span>0 - initialize IGRF field
                once per year (year.5);&nbsp; n - n is the&nbsp; frequency (in days) starting on January
                1st of each year (i.e. if options(2nd element)=15 then IGRF will be updated on the
                following days of the year: 1, 15, 30, 45 ...)<br />
            </li>
            <li>
                <span style="FONT-WEIGHT: bold">options(3rd element): </span>resolution to compute
                L* (0 to 9) where 0 is the recomended value to ensure a good ratio precision/computation
                time (i.e. an error of ~2% at L=6). The higher the value the better will be the precision,
                the longer will be the computing time. Generally there is not much improvement for
                values larger than 4. Note that this parameter defines the integration step (&#952;)
                along the field line such as d&#952;=(&#960;)/(720*[options(3rd element)+1])<br />
            </li>
            <li>
                <span style="FONT-WEIGHT: bold">options(4th element): </span>resolution to compute
                L* (0 to 9). The higher the value the better will be the precision, the longer will
                be the computing time. It is recommended to use 0 (usually sufficient) unless L* is
                not computed on a LEO orbit. For LEO orbit higher values are recommended. Note that
                this parameter defines the integration step (&#966;) along the drift shell such as
                d&#966;=(2&#960;)/(25*[options(4th element)+1])<br />
            </li>
            <li>
                <span style="FONT-WEIGHT: bold">options(5th element):</span> allows to select an internal
                magnetic field model (default is set to IGRF) 
            </li>
        </ol>
        <div style="MARGIN-LEFT: 80px">
            <ul>
                <li>
                    0 = IGRF 
                </li>
                <li>
                    1 = Eccentric tilted dipole 
                </li>
                <li>
                    2 = Jensen&amp;Cain 1960 
                </li>
                <li>
                    3 = GSFC 12/66 updated to 1970<br />
                </li>
                <li>
                    4 = User own magnetic field. The library then called a routine which has to be written by the user
                    myOwnMagField(xGEO,Bxint) where inputs are
                    xGEO a double array of 3 elements (x,y,z) containing geographic cartesian coordinates in Re and
                    outputs are Bxint a double array of 3 elements (Bx,By,Bz) containing magnetic field components in geographic cartesian coordinates in nT<br />
                </li>
                <li>
                    5 = Centered dipole
                </li>
            </ul>
        </div>
    </div>
    <p>
        <font face="ARIAL, HELVETICA"><b>sysaxes</b>, <b>sysaxesIN</b>, and <b>sysaxesOUT</b>: long integer to define which coordinate
        system is provided in</font> 
        <br />
    </p>
    <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">0: GDZ (alti, lati, East
        longi - km,deg.,deg)</font> 
        <br />
        <font face="ARIAL, HELVETICA">1: GEO (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">2: GSM (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">3: GSE (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">4: SM (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">5: GEI (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">6: MAG (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">7: SPH (geo in spherical) - (radial distance, lati,
        East longi - Re, deg., deg.)<br />
        </font><font face="ARIAL, HELVETICA">8: RLL&nbsp; (radial distance, lati, East longi
        - Re, deg., deg. - prefered to 7)</font> 
        <br />
    </div>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>iyear</b>, <b>iyr</b> or <b>iyearsat</b>: array(NTIME_MAX) of long integer year when
        measurements are given. /font> 
    <br>
        <font face="ARIAL, HELVETICA"><b>idoy:</b> array(NTIME_MAX) of long integer doy when
        measurements are given</font> 
	  <br>
        <font face="ARIAL, HELVETICA"><b>UT</b> or <b>secs</b>: array(NTIME_MAX) of double, UT in seconds</font> 
<br>
<i> Note: In matlab, year/doy/UT arguments are replaced by the single <b>matlabd</b> argument, which is a Matlab date numbers (a double precision day counter created with <b>datenum</b>). They can be generated, if needed, using the helper function [iyear,idoy,UT] = <b>onera_desp_lib_matlabd2yds</b>(matlabd).  </i>
    <p>
        <font face="ARIAL, HELVETICA"><b>x1:</b> array(NTIME_MAX) of double, first coordinate
        according to sysaxes. If sysaxes is 0 then altitude has to be in km otherwise use
        dimensionless variables (in Re)</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>x2:</b> array(NTIME_MAX) of double, second coordinate
        according to sysaxes. If sysaxes is 0 then latitude has to be in degrees otherwise
        use dimensionless variables (in Re)</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>x3:</b> array(NTIME_MAX) of double, third coordinate
        according to sysaxes. If sysaxes is 0 then longitude has to be in degrees otherwise
        use dimensionless variables (in Re).</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>alpha:</b> array(NALPHA_MAX) double, pitch-angle at input
        location (in degres).</font> 
    </p>
	<p>
        <font face="ARIAL, HELVETICA"><b>R0:</b> double, radius, in Re, of the minimum allowed radial
	  distance along the drift orbit (use R0 &lt; 1) for the drift loss cone.</font> 
	</p>
    <p>
        <font face="ARIAL, HELVETICA"><b>maginput: </b>array (25,NTIME_MAX) of double to specify
        magnetic fields inputs such as:<b> 
        <br />
        </b></font>
    </p>
    <ol>
        <li>
            <font face="ARIAL, HELVETICA"><b>maginput(1st element,*) =</b></font><font face="ARIAL, HELVETICA"><b>Kp:</b> value
            of Kp as in OMNI2 files but has to be double instead of integer type. 
	    (NOTE, consistent with OMNI2, this is Kp*10, and it is in the range 0 to 90)</font> 
        </li>
        <li>
            <font face="ARIAL, HELVETICA"><b>maginput(2nd element,*) =</b></font><font face="ARIAL, HELVETICA"><b>Dst:</b> Dst
            index (nT)</font> 
        </li>
        <li>
            <font face="ARIAL, HELVETICA"><b>maginput(3rd element,*) =</b></font><font face="ARIAL, HELVETICA"><b>dens:</b> Solar
            Wind density (cm<sup>-3</sup>)</font> 
        </li>
        <li>
            <font face="ARIAL, HELVETICA"><b>maginput(4th element,*) =</b></font><font face="ARIAL, HELVETICA"><b>velo:</b> Solar
            Wind velocity (km/s)</font> 
        </li>
        <li>
            <font face="ARIAL, HELVETICA"><b>maginput(5th element,*) =</b></font><font face="ARIAL, HELVETICA"><b>Pdyn:</b> Solar
            Wind dynamic pressure (nPa)</font> 
        </li>
        <li>
            <font face="ARIAL, HELVETICA"><b>maginput(6th element,*) =</b></font><font face="ARIAL, HELVETICA"><b>ByIMF:</b> GSM
            y component of IMF mag. field (nT)</font> 
        </li>
        <li>
            <font face="ARIAL, HELVETICA"><b>maginput(7th element,*) =</b></font><font face="ARIAL, HELVETICA"><b>BzIMF:</b> GSM
            z component of IMF mag. field (nT)</font> 
        </li>
        <li>
            <font face="ARIAL, HELVETICA"><b>maginput(8th element,*) =</b></font><font face="ARIAL, HELVETICA"><b>G1:</b>&nbsp;
            G1=&lt; Vsw*(Bperp/40)<sup>2</sup>/(1+Bperp/40)*sin<sup>3</sup>(theta/2) &gt; where
            the &lt;&gt; mean an average over the previous 1 hour, Vsw is the solar wind speed,
            Bperp is the transverse IMF component (GSM) and theta it's clock angle.</font> 
        </li>
        <li>
            <font face="ARIAL, HELVETICA"><b>maginput(9th element,*) =</b></font><font face="ARIAL, HELVETICA"><b>G2:</b> G2=&lt;
            a*Vsw*Bs &gt; </font><font face="ARIAL, HELVETICA">where the &lt;&gt; mean an average
            over the previous 1 hour, Vsw is the solar wind speed, Bs=|IMF Bz| when IMF Bz &lt;
            0 and Bs=0 when IMF Bz &gt; 0, a=0.005.</font> 
        </li>
        <li>
            <font face="ARIAL, HELVETICA"><b>maginput(10th element,*) =</b></font><font face="ARIAL, HELVETICA"><b>G3:</b>&nbsp;
            G3=&lt; Vsw*Dsw*Bs /2000.&gt;</font> 
            <br />
            <font face="ARIAL, HELVETICA">where the &lt;&gt; mean an average over the previous
            1 hour, Vsw is the solar wind speed, Dsw is the solar wind density, Bs=|IMF Bz| when
            IMF Bz &lt; 0 and Bs=0 when IMF Bz &gt; 0.</font> 
        </li>
        <li>
            <font face="ARIAL, HELVETICA"><b>maginput(11th element,*) =W1 </b>see definition in<b> </b></font><font size=+0>(JGR-A,
            v.110(A3), 2005.) <a href="http://geo.phys.spbu.ru/~tsyganenko/TS05.pdf">(PDF
            1.2MB)</a></font> 
        </li>
        <li>
            <font face="ARIAL, HELVETICA"><b>maginput(12th element,*) =W2 </b>see definition in<b> </b></font><font size=+0>(JGR-A,
            v.110(A3), 2005.) <a href="http://geo.phys.spbu.ru/~tsyganenko/TS05.pdf">(PDF
            1.2MB)</a></font> 
        </li>
        <li>
            <font face="ARIAL, HELVETICA"><b>maginput(13th element,*) =W3 </b>see definition in<b> </b></font><font size=+0>(JGR-A,
            v.110(A3), 2005.) <a href="http://geo.phys.spbu.ru/~tsyganenko/TS05.pdf">(PDF
            1.2MB)</a></font> 
        </li>
        <li>
            <font face="ARIAL, HELVETICA"><b>maginput(14th element,*) =W4 </b>see definition in<b> </b></font><font size=+0>(JGR-A,
            v.110(A3), 2005.) <a href="http://geo.phys.spbu.ru/~tsyganenko/TS05.pdf">(PDF
            1.2MB)</a></font> 
        </li>
        <li>
            <font face="ARIAL, HELVETICA"><b>maginput(15th element,*) =W5 </b>see definition in<b> </b></font><font size=+0>(JGR-A,
            v.110(A3), 2005.) <a href="http://geo.phys.spbu.ru/~tsyganenko/TS05.pdf">(PDF
            1.2MB)</a></font> 
        </li>
        <li>
            <font face="ARIAL, HELVETICA"><b>maginput(16th element,*) =W6 </b>see definition in<b> </b></font><font size=+0>(JGR-A,
            v.110(A3), 2005.) <a href="http://geo.phys.spbu.ru/~tsyganenko/TS05.pdf">(PDF
            1.2MB)</a></font> 
        </li>
        <li>
            <font face="ARIAL, HELVETICA"><b>maginput(17th element,*) =AL </b>the auroral index<b> 
            <br />
            </b></font> 
        </li>
        <li>
            <font face="ARIAL, HELVETICA"><b>maginput(18th element,*) to </b></font><font face="ARIAL, HELVETICA"><b>maginput(25th
            element,*): </b>for future use</font> <font face="ARIAL, HELVETICA"><b>
            <br />
            </b></font>
        </li>
    </ol>
    <p>
        <font face="ARIAL, HELVETICA"><b>Lm:</b> L McIlwain (array(NTIME_MAX,NALPHA_MAX) of double)</font> 
        <br />

    <p>
        <font face="ARIAL, HELVETICA"><b>IMPORTANT:</b> When using a non dipole field Lm is
        pitch-angle dependent because of the McIlwain L definition which has some limitation
        but this dependency has nothing to do with shell-splitting!<br />
        </font>
    </p>

        <font face="ARIAL, HELVETICA"><b>Lstar or &#934; :</b> L Roederer&nbsp; or &#934;=2&#960;*Bo*/Lstar
        [nT Re<sup>2</sup>] (array(NTIME_MAX,NALPHA_MAX) of double)</font> 
        <br />
        <font face="ARIAL, HELVETICA"><b>Blocal:</b> magnitude of magnetic field at point (array(NTIME_MAX,NALPHA_MAX)
        of double) - [nT]</font> 
        <br />
        <font face="ARIAL, HELVETICA"><b>Bmir</b> or <b>Bmirror:</b> magnitude of magnetic field at mirror point (array(NTIME_MAX,NALPHA_MAX)
        of double) - [nT]</font> 
        <br />
        <font face="ARIAL, HELVETICA"><b>Bmin:</b> magnitude of magnetic field at equator
        (array(NTIME_MAX,NALPHA_MAX) of double) - [nT]</font> 
        <br />
        <font face="ARIAL, HELVETICA"><b>XJ:</b> I, related to second adiabatic invariant
        (array(NTIME_MAX,NALPHA_MAX) of double)</font> - [Re]<br />
        <font face="ARIAL, HELVETICA"><b>MLT:</b> magnetic local time in hours, (array(NTIME_MAX,NALPHA_MAX)
        of double) - [hour]</font> 

      <p>

	<font face="ARIAL, HELVETICA"><b>POSIT:</b> (note: size
	varies. Changes from what's given here will be provided in the
	function definitions). xGEO,yGEO and zGEO along the drift
	shell, (array(3,1000,48) of double)</font> <br /> 1st element:
	x, y, z GEO coord, 2nd element: points along field line, 3rd
	element: number of field lines. Note, sometimes the long
	dimension is 3000 rather than 1000; see specific functions for
	clarification. <br />

	<font face="ARIAL, HELVETICA"><b>Nposit:</b> (note: size
	varies. Changes from what's given here will be provided in the
	function definitions) long integer array (48) providing the
	number of points along the field line for each field line
	traced in 2nd element of POSIT array (max 1000 for some functions, 3000 for others).</font>
    <p>
        <font face="ARIAL, HELVETICA"><b>Note:</b> Posit is organized as follow: array(xyz,along
        bounce,drift index). Nposit tells how many of the 1000 (or 3000) points available are used to
        described one bounce.</font> 
        <br />
    </p>

      <br>
        <br />
        <br />
        <u>Comments on adiabatic invariants:</u> 
        <br />
        J<sub>2</sub>=2*p*I/(2*&#960;) where p is the particle momemtum - [kg m<sup>2</sup> s<sup>-2</sup> Re] 
        <br />
        J<sub>3</sub>=q/(2*&#960;) *&#934; - <font face="Arial">[C nT Re<sup>2</sup>] </font>
    </p>
    <p>
        <br />
        <u>Below is provided an chart explaining the logic for the coding of Lm and Lstar
        from the routine:</u> 
        <br />
        <br />
        &nbsp;<img style="WIDTH: 500px; HEIGHT: 375px" alt="" src="Lstar.jpg" /> 
    </p>


    <hr><a name="MAKE_LSTAR"></a> 
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">MAKE_LSTAR</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">This function allows one to compute magnetic coordinate
    at any s/c position, i.e. L, L*, Blocal/Bmirror, Bequator.&nbsp;A set of internal/external
    field&nbsp;can be selected.</font><br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>

      <b>ntime, kext, options, sysaxes, iyear, idoy, UT, x1, x2, x3, maginput</b> <p>

      see <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>

	<p>
        <font face="ARIAL, HELVETICA"><b>IMPORTANT:</b> all inputs must be present. For those
        which are not used a dummy value can be provided.</font> 
        <br />
        &nbsp; 

    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>

      <b>Lm, Lstar or &#934;, Blocal, Bmin, XJ, MLT</b> <p>

      see <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>

    <h3>
        <br />
    </h3>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">[Lm,Lstar,Blocal,Bmin,J,MLT] = onera_desp_lib_make_lstar(kext,options,sysaxes,matlabd,x1,x2,x3,maginput) </font>
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'make_lstar_', ntime,kext,options,sysaxes,iyear,idoy,ut,
    x1,x2,x3, maginput, lm,lstar,blocal,bmin,xj,mlt, /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call make_lstar1(ntime,kext,options,sysaxes,iyear,idoy,ut,
    x1,x2,x3, maginput, lm,lstar,blocal,bmin,xj,mlt)</font> 
    <p>
        <hr><a name="LANDI2LSTAR"></a> 
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">LANDI2LSTAR</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">This function allows one to compute magnetic coordinate
    at any s/c position, i.e. L, L*, Blocal/Bmirror, Bequator.&nbsp;A set of internal/external
    field&nbsp;can be selected. Right now this routine differs from MAKE_LSTAR because L*
    is deduced from Lm, I and day of year empirically. This is set only for IGRF+Olson-Pfitzer quiet
     field model (kext can only be 5). The errors in L* values are less than 2%.</font><br />

    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>

      <b>ntime, kext, options, sysaxes, iyear, idoy, UT, x1, x2, x3, maginput </b>

	<br><br>

      see <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>

	<br><br>

        <font face="ARIAL, HELVETICA"><b>IMPORTANT:</b> all inputs must be present. For those
        which are not used a dummy value can be provided.</font> 

    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>

      <b>Lm, Lstar or &#934;, Blocal, Bmin, XJ, MLT</b> <p>

      see <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>

    </p>

    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">[Lm,Lstar,Blocal,Bmin,J,MLT] = onera_desp_lib_landi2lstar(kext,options,sysaxes,matlabd,x1,x2,x3,maginput) </font>
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'landi2lstar_', ntime,kext,options,sysaxes,iyear,idoy,ut,
    x1,x2,x3, maginput, lm,lstar,blocal,bmin,xj,mlt, /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call landi2lstar1(ntime,kext,options,sysaxes,iyear,idoy,ut,
    x1,x2,x3, maginput, lm,lstar,blocal,bmin,xj,mlt)</font> 
      <p>
        <hr><a name="EMPIRICALLSTAR"></a> 
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">EMPIRICALLSTAR</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">This function allows one to compute L* empirically being given Lm, I and day of year.
     This is set only for IGRF+Olson-Pfitzer quiet
     field model (kext can only be 5) so Lm and I provided as input must be computed with this field. The errors in L* values are less than 2%.</font><br />








    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>

      <b>ntime, kext, options, iyearsat, idoy, maginput, Lm, XJ</b>


	<br><br>

      see <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>

	<br><br>

        <font face="ARIAL, HELVETICA"><b>IMPORTANT:</b> all inputs must be present. For those
        which are not used a dummy value can be provided.</font> 

    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>

      <b>Lstar or &#934;</b> <p>

      see <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>

    </p>


    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Lstar = onera_desp_lib_empiricallstar(kext,options,matlabd,maginput,Lm,J) </font>
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'empiricalLstar_', ntime,kext,options,iyearsat,idoy,
    maginput, lm,xj,lstar, /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call EmpiricalLstar1(ntime,kext,options,iyearsat,idoy,maginput, 
    lm,xj,lstar)</font> 
    <p>
        <br />
        <hr><a name="MAKE_LSTAR_SHELL_SPLITTING"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">MAKE_LSTAR_SHELL_SPLITTING</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">This function allows one to compute the magnetic coordinates
    at any s/c position and pitch-angle, i.e. L, L*, Bmirror, Bequator.&nbsp;A set of internal/external
    field&nbsp;can be selected</font><font face="ARIAL, HELVETICA">.</font> 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>

      <b>ntime, Nipa, kext, options, sysaxes, iyear, idoy, UT, x1, x2, x3, alpha, maginput</b> <p>

      see <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>

    <p>
        <font face="ARIAL, HELVETICA"><b>IMPORTANT:</b> all inputs must be present. For those
        which are not used a dummy value can be provided.</font> 
        <br />
        &nbsp; 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>

      <b>Lm, Lstar or &#934;, Blocal, Bmin, XJ, MLT</b> <p>

      see <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>

    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">[Lm,Lstar,Bmirror,Bmin,J,MLT] = onera_desp_lib_make_lstar_shell_splitting(kext,options,sysaxes,matlabd,x1,x2,x3,alpha,maginput) </font>
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'make_lstar_shell_splitting_',
    ntime,Npa,kext,options,sysaxes,iyear,idoy,ut, x1,x2,x3,alpha,maginput,lm,lstar,blocal,bmin,xj,mlt,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call make_lstar_shell_splitting1(ntime,Npa,kext,options,sysaxes,iyear,idoy,ut,
    x1,x2,x3, alpha,maginput,lm,lstar,blocal,bmin,xj,mlt)</font> 
    <p>
        <br />
        <hr><a name="LANDI2LSTAR_SHELL_SPLITTING"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">LANDI2LSTAR_SHELL_SPLITTING</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">This function allows one to compute the magnetic coordinates
    at any s/c position and pitch-angle, i.e. L, L*, Bmirror, Bequator.&nbsp;A set of internal/external
    field&nbsp;can be selected. 
    Right now this routine differs from MAKE_LSTAR_SHELL_SPLITTING because L* is deduced from Lm, I and day of year empirically. 
    This is set only for IGRF+Olson-Pfitzer quiet field model (kext can only be 5). 
    The errors in L* values are less than 2%.</font> 



    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>

      <b>ntime, Nipa, kext, options, sysaxes, iyear, idoy, UT, x1, x2, x3, alpha, maginput</b> <p>

      see <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>

    <p>
        <font face="ARIAL, HELVETICA"><b>IMPORTANT:</b> all inputs must be present. For those
        which are not used a dummy value can be provided.</font> 
        <br />
        &nbsp; 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>

      <b>Lm, Lstar or &#934;, Bmirror, Bmin, XJ, MLT</b> <p>

      see <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>
	<p>

    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font>  
    </h3>
    <font face="ARIAL, HELVETICA">[Lm,Lstar,Bmirror,Bmin,J,MLT] = onera_desp_lib_landi2lstar_shell_splitting(kext,options,sysaxes,matlabd,x1,x2,x3,alpha,maginput) </font>
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'landi2lstar_shell_splitting_',
    ntime,Npa,kext,options,sysaxes,iyear,idoy,ut, x1,x2,x3,alpha,maginput,lm,lstar,blocal,bmin,xj,mlt,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call landi2lstar_shell_splitting1(ntime,Npa,kext,options,sysaxes,iyear,idoy,ut,
    x1,x2,x3, alpha,maginput,lm,lstar,blocal,bmin,xj,mlt)</font> 
    <p>
        <br />
        <hr><a name="DRIFT_SHELL"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">DRIFT_SHELL</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">This function traces a full drift shell for particles
    that have their mirror point at the input location.&nbsp; The output is a full array
    of positions of the drift shell, usefull for plotting and visualisation 
    (for just the points on the drift-bounce orbit, use <a href="#DRIFT_BOUNCE_ORBIT">DRIFT_BOUNCE_ORBIT</a>).</font>&nbsp;<font face="Arial">A
    set of internal/external field can be selected</font><font face="ARIAL, HELVETICA">.</font> 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>




    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>

      <b>kext, options, sysaxes, iyear, idoy, UT, x1, x2, x3, maginput</b> <p>

      see <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>

    <p>
        <font face="ARIAL, HELVETICA"><b>IMPORTANT:</b> all inputs must be present. For those
        which are not used a dummy value can be provided.</font> 
        <br />
        &nbsp; 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>

      <b>Lm, Lstar or &#934;, Blocal, Bmin, XJ, POSIT, Nposit</b> <br>
	Blocal is (1000,48), Lm, Lstar/&#934;, Bmin, and XJ are a scalars<p>

      see <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>

    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">[Lm,Lstar,Blocal,Bmin,J,POSIT] = onera_desp_lib_drift_shell(kext,options,sysaxes,matlabd,x1,x2,x3,maginput) </font>
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'drift_shell_',&nbsp;
    kext,options,sysaxes,iyear,idoy,ut,&nbsp; x1,x2,x3, maginput, lm,lstar,blocal,bmin,xj,posit,Nposit,&nbsp;
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call drift_shell1(kext,options,sysaxes,iyear,idoy,ut,
    x1,x2,x3, maginput, lm,lstar,blocal,bmin,xj,posit,Nposit)</font> 
    <p>
        <br />
        <hr><a name="DRIFT_BOUNCE_ORBIT"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">DRIFT_BOUNCE_ORBIT</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">This function traces a full
    drift-bounce orbit for particles with a specified pitch angle at
    the input location.&nbsp; The output is a full array of positions
    of the drift-bounce orbit, usefull for computing drift-bounce
    averages.  Key differences from <a
    href="#DRIFT_SHELL">DRIFT_SHELL</a>: (1) only positions between
    mirror points are returned, (2) <b>25</b> rather than 48 azimuths
    are returned, (3) Lstar accuracy respects options(3) and
    options(4), (4) a new parameter R0 is required which specifies the
    minimum radial distance allowed along the drift path (usually
    R0=1, but use R0&lt;1 in the drift loss cone), (5) hmin and
    hmin_lon outputs provide the altitude and longitude (GDZ) of the
    minimum altitude point along the orbit (among those traced, not
    just those returned).</font>&nbsp;<font face="Arial">A set of
    internal/external field can be selected</font><font face="ARIAL,
    HELVETICA">.</font> 


    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
	<b> kext, options, sysaxes, iyear, idoy, UT, x1, x2, x3, alpha, maginput, R0 </b> <p>

      see <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>

    <p>
        <font face="ARIAL, HELVETICA"><b>IMPORTANT:</b> all inputs must be present. For those
        which are not used a dummy value can be provided.</font> 
        <br />
        &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>

	<b> Lm, Lstar, Blocal, Bmin, Bmirror, XJ, POSIT, Nposit, hmin, hmin_lon</b> <br>
	Note: POSIT is size (3,1000,25) and Nposit is size (25) <br>
	Blocal is (1000,25), Lm, Lstar/&#934;, Bmin, Bmirror, XJ, hmin, and hmin_lon are a scalars<p>

      see <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>

	<p>
    <font face="ARIAL, HELVETICA"><b>hmin:</b> double, minimum altitude, GDZ, km, along the drift orbit</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>hmin_lon:</b> double, longitude, GDZ, degrees, at hmin.</font> 
    <br />

    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">[Lm,Lstar,Blocal,Bmin,Bmir,J,POSIT,hmin,hmin_lon] = onera_desp_lib_drift_bounce_orbit(kext,options,sysaxes,matlabd,x1,x2,x3,alpha,maginput,R0) </font>
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'drift_bounce_orbit2_',&nbsp;
    kext,options,sysaxes,iyear,idoy,ut,&nbsp; x1,x2,x3,alpha, maginput,R0, lm,lstar,blocal,bmin,bmir,xj,posit,Nposit,hmin,hmin_lon,&nbsp;
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call drift_bounce_orbit2_1(kext,options,sysaxes,iyear,idoy,ut,
    x1,x2,x3,alpha, maginput,R0 lm,lstar,blocal,bmin,bmir,xj,posit,Nposit,hmin,hmin_lon)</font> 
    <p>
        <br />
        <hr><a name="FIND_MIRROR_POINT"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">FIND_MIRROR_POINT</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">This function finds the magnitude and location of the
    mirror point along a field line traced from any given location and local pitch-angle
    for a set of internal/external field to be selected.</font>&nbsp;<br />




    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
	<b> kext, options, sysaxes, iyear, idoy, UT, x1, x2, x3, alpha, maginput </b> <p>

      see <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>

    <p>
        <font face="ARIAL, HELVETICA"><b>IMPORTANT:</b> all inputs must be present. For those
        which are not used a dummy value can be provided.</font> 
        <br />
        &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>

	<b> Blocal, Bmir, POSIT</b> <br>
      Blocal and Bmir are scalars. POSIT is size (3) and provides the GEO coordinaets of the mirror point in Re.

      see <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>

    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">[Blocal,Bmirror,xGEO] = onera_desp_lib_find_mirror_point(kext,options,sysaxes,matlabd,x1,x2,x3,alpha,maginput) </font>
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name,&nbsp; 'find_mirror_point_',
    kext,options,sysaxes,iyear,idoy,ut, x1,x2,x3,alpha,maginput, blocal,bmir,posit, /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call find_mirror_point1(kext,options,sysaxes,iyear,idoy,ut,
    x1,x2,x3,alpha, maginput,blocal,bmir,posit)</font> 
    <p>
        <br />
        <hr><a name="FIND_MAGEQUATOR"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">FIND_MAGEQUATOR</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">This function finds the GEO coordinates of the magnetic
    equator along the field line starting from input location for a set of internal/external
    field to be selected.</font>&nbsp;<br />

    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>

      <b> kext, options, sysaxes, iyear, idoy, UT, x1, x2, x3, maginput</b> <p>

      see <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>

	<p>
        <font face="ARIAL, HELVETICA"><b>IMPORTANT:</b> all inputs must be present. For those
        which are not used a dummy value can be provided.</font> 
        <br />
        &nbsp; 

    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>Bmin:</b> magnitude of magnetic field at equator
    (double)</font> 
    <p>
        <font face="ARIAL, HELVETICA"><b>POSIT:</b> xGEO,yGEO and zGEO of the magnetic equator
        location, (array(3) of double)</font> 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">[Bmin,xGEO] = onera_desp_lib_find_magequator(kext,options,sysaxes,matlabd,x1,x2,x3,maginput) </font>
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'find_magequator_',&nbsp;
    kext,options,sysaxes,iyear,idoy,ut,&nbsp; x1,x2,x3, maginput, bmin,posit,&nbsp; /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call find_magequator1(kext,options,sysaxes,iyear,idoy,ut,&nbsp;
    x1,x2,x3, maginput,bmin,posit)</font> 
    <p>
        <br />
        <hr><a name="FIND_FOOT_POINT"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">FIND_FOOT_POINT</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">This function finds the of the field line crossing a specified altitude in a specified hemisphere
    for a set of internal/external field to be selected.</font>&nbsp;<br />

    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>

      <b> kext, options, sysaxes, iyear, idoy, UT, x1, x2, x3, stop_alt, hemi_flag, maginput</b> <p>

      See <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>

    <p>
        <font face="ARIAL, HELVETICA"><b>stop_alt:</b> double, desired altitude of field-line crossing, km.</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>hemi_flag:</b> long integer, hemisphere flag. </font> 
    </p>
    <div style="MARGIN-LEFT: 40px">
      <font face="ARIAL, HELVETICA">0&nbsp;&nbsp; = same magnetic hemisphere as starting point</font><br />
      <font face="ARIAL, HELVETICA">+1&nbsp;&nbsp; = northern magnetic hemisphere</font><br />
      <font face="ARIAL, HELVETICA">-1&nbsp;&nbsp; = southern magnetic hemisphere</font><br />
      <font face="ARIAL, HELVETICA">+2&nbsp;&nbsp; = opposite magnetic hemisphere as starting point</font><br />
    </div>

    <p>
        <font face="ARIAL, HELVETICA"><b>IMPORTANT:</b> all inputs must be present. For those
        which are not used a dummy value can be provided.</font> 
        <br />
        &nbsp; 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>XFOOT:</b> location of foot point, GDZ, (array(3) of double)</font><br />
    <font face="ARIAL, HELVETICA"><b>BFOOT:</b> magnetic field vector at foot point, GEO, nT, (array(3) of double)</font><br />
    <font face="ARIAL, HELVETICA"><b>BFOOTMAG:</b> magnetic field magnitude at foot point, GEO, nT, (array(3) of double)</font><br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">[Xfoot,Bfoot,BfootMag] = onera_desp_lib_find_foot_point(kext,options,sysaxes,matlabd,x1,x2,x3,stop_alt,hemi_flag,maginput)</font>
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name,&nbsp; 'find_foot_point_',
    kext,options,sysaxes,iyear,idoy,ut, x1,x2,x3,stop_alt,hemi_flag,maginput, xfoot,bfoot,bfootmag, /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">
        call find_foot_point1(kext,options,sysaxes,iyearsat,idoy,UT,xIN1,xIN2,xIN3,stop_alt,hemi_flag,maginput,XFOOT,BFOOT,BFOOTMAG)
</font> 
    <p>
        <br />
        <hr><a name="GET_FIELD"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GET_FIELD</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
      This function is deprecated. Use <a href=#GET_FIELD_MULTI>GET_FIELD_MULTI</a> instead.

      <br>

        <hr><a name="GET_FIELD_MULTI"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GET_FIELD_MULTI</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">This function computes the GEO vector of the magnetic
    field at input location for a set of internal/external magnetic field to be selected.</font>&nbsp;<br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>

      <b>ntime, kext, options, sysaxes, iyear, idoy, UT, x1, x2, x3, maginput</b> <p>

      See <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>


                <br />
                <font face="ARIAL, HELVETICA"><b>IMPORTANT:</b> all inputs must be present. For those
                which are not used a dummy value can be provided.</font> 

    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>Bgeo:</b> BxGEO,ByGEO and BzGEO of the magnetic field
    (nT), (array(3,NTIME_MAX) of double)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>Bl:</b> magnitude of magnetic field (array(NTIME_MAX) of double) (nT)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">[Bgeo,B] = onera_desp_lib_get_field(kext,options,sysaxes,matlabd,x1,x2,x3,maginput)</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'get_field_multi_idl_',ntime,kext,options,sysaxes,iyear,idoy,ut,
    x1,x2,x3, maginput,Bgeo, Bl,&nbsp; /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call GET_FIELD_MULTI(ntime,kext,options,sysaxes,iyear,idoy,ut,
    x1,x2,x3, maginput,Bgeo,Bl)</font> 
    <p>
        <br />

        <hr><a name="GET_BDERIVS"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GET_BDERIVS</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">This function computes the magnetic field and its 1st-order derivatives
	at each input location for a set of internal/external magnetic field to be selected.</font>&nbsp;<br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>

      <b>ntime, kext, options, sysaxes, dX, iyear, idoy, UT, x1, x2, x3, maginput</b> <p>

      See <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>

<p>

	<b>dX:</b> dX is the step size, in RE for the numerical derivatives (recommend 1E-3), double scalar.

                <p>
                <font face="ARIAL, HELVETICA"><b>IMPORTANT:</b> all inputs must be present. For those
                which are not used a dummy value can be provided.</font> 

    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>Bgeo:</b> BxGEO,ByGEO and BzGEO of the magnetic field
    (nT), (array(3,NTIME_MAX) of double)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>Bmag:</b> magnitude of magnetic field (array(NTIME_MAX) of double) (nT)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>gradBmag:</b> gradient (GEO) of magnitude of magnetic field (array(3,NTIME_MAX) of double) (nT)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>diffB:</b> derivatives of magnetic field vector (array(3,3,NTIME_MAX) of double) (nT)<br>
        diffB(i,j,t) = dB_i/dx_j at t'th location. GEO coordinates. </font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">[Bgeo,B,gradBmag,diffB] = onera_desp_lib_get_bderivs(kext,options,sysaxes,matlabd,x1,x2,x3,maginput,...)</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'get_bderivs_idl',ntime,kext,options,sysaxes,dX,iyear,idoy,ut,
    x1,x2,x3, maginput,Bgeo,Bmag,gradBmag,diffB,&nbsp; /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call GET_BDERIVS(ntime,kext,options,sysaxes,dX,iyear,idoy,ut,
    x1,x2,x3, maginput,Bgeo,Bmag,gradBmag,diffB)</font> 
    <p>
        <br />

        <hr><a name="COMPUTE_GRAD_CURV_CURL"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">COMPUTE_GRAD_CURV_CURL</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">This function computes gradient and curvature force factors and div/curl of B
      from the outputs of <a href=#GET_BDERIVS>GET_BDERIVS</a></font>&nbsp;<br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>

      <b>ntime, Bgeo, Bmag, gradBmag, diffB</b> defined as for <a href=#GET_BDERIVS>GET_BDERIVS</a> <p>

    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>

      <font face="ARIAL, HELVETICA"><b>grad_par:</b> gradient of Bmag along B nT/RE, (array(NTIME_MAX) of double)</font> <br />
      <font face="ARIAL, HELVETICA"><b>grad_perp:</b>  gradient of Bmag perpendicular to B nT/RE (array(3,NTIME_MAX) of double)</font> <br />
      <font face="ARIAL, HELVETICA"><b>grad_drift:</b> (bhat x grad_perp)/B, 1/RE (part of gradient drift velocity) (array(3,NTIME_MAX) of double)</font> <br />
      <font face="ARIAL, HELVETICA"><b>curvature:</b> (bhat dot grad)bhat, 1/RE (part of curvature force) (array(3,NTIME_MAX) of double)</font> <br />
      <font face="ARIAL, HELVETICA"><b>Rcurv:</b> 1/|curvature| RE (radius of curvature) (array(3,NTIME_MAX) of double)</font> <br />
      <font face="ARIAL, HELVETICA"><b>curv_drift:</b> (bhat x curvature), 1/RE (part of curvature drift) (array(NTIME_MAX) of double)</font> <br />
      <font face="ARIAL, HELVETICA"><b>curlB:</b> curl of B (nT/RE) (part of electrostatic current term) (array(3,NTIME_MAX) of double)</font> <br />
      <font face="ARIAL, HELVETICA"><b>divB:</b> divergence of B (nT/RE) (should be zero!) (array(NTIME_MAX) of double)</font> <br />

      <p>

    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">[grad_par,grad_perp,grad_drift,curvature,Rcurv,curv_drift,curlB,divB] = onera_desp_lib_compute_grad_curv_curl(Bgeo,B,gradBmag,diffB)</font>
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'compute_grad_curv_idl',ntime,Bgeo,Bmag,gradBmag,diffB,
	grad_par,grad_perp,grad_drift,curvature,Rcurv,curv_drift,curlB,divB,
	&nbsp; /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font>
    </h3>

    <font face="ARIAL, HELVETICA">call COMPUTE_GRAD_CURV_CURL(ntime,Bgeo,Bmag,gradBmag,diffB,
	grad_par,grad_perp,grad_drift,curvature,Rcurv,curv_drift,curlB,divB)</font>
    <p>
        <br />

        <hr><a name="TRACE_FIELD_LINE"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">TRACE_FIELD_LINE2</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">This function traces a full field line which crosses
    the input position.&nbsp; The output is a full array of positions of the field line,
    usefull for plotting and visualisation for a set of internal/external fields to be
    selected. A new option (R0) for TRACE_FIELD_LINE2 allows user to specify the radius (RE)
    of the reference surface between which the line is traced (R0=1 in TRACE_FIELD_LINE) </font>&nbsp;<br />



    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>

      <b>kext, options, sysaxes, iyear, idoy, UT, x1, x2, x3, maginput, R0</b> <p>

      See <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>

   <p>
        <font face="ARIAL, HELVETICA"><b>R0: </b>double, specifies radius of reference surface
	between which field line is traced.</font>
    </p>
    <br />
    <font face="ARIAL, HELVETICA"><b>IMPORTANT:</b> all inputs must be present. For those
    which are not used a dummy value can be provided.</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>


      <b>Lm, Blocal, Bmin, XJ, POSIT, Nposit</b> <p>
      See <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a><br>
	POSIT is (3,3000), Nposit is a scalar.

    &nbsp; 
    <p>
        <br />
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">[Lm,Blocal,Bmin,J,POSIT] = onera_desp_lib_trace_field_line(kext,options,sysaxes,matlabd,x1,x2,x3,maginput,R0)</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'trace_field_line2_',&nbsp;
    kext,options,sysaxes,iyear,idoy,ut,&nbsp; x1,x2,x3,maginput,R0,lm,blocal,bmin,xj,posit,Nposit,&nbsp;
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call trace_field_line2_1(kext,options,sysaxes,iyear,idoy,ut,
    x1,x2,x3, maginput,R0, lm,blocal,bmin,xj,posit,Nposit)</font> 
    <p>
        <br />
        <hr><a name="TRACE_FIELD_LINE_TOWARD_EARTH"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">TRACE_FIELD_LINE_TOWARD_EARTH</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">This function traces a field line from
    the input position to the Earth surface.&nbsp; The output is a full array of positions of the field line,
    usefull for plotting and visualisation for a set of internal/external fields to be
    selected.</font>&nbsp;<br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>

      <b>kext, options, sysaxes, iyear, idoy, UT, x1, x2, x3, maginput, ds</b> <p>

      See <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>

    <p>
        <font face="ARIAL, HELVETICA"><b>ds:</b> double, Integration step along field line (in Re).</font> 
    </p>
    <br />
    <font face="ARIAL, HELVETICA"><b>IMPORTANT:</b> all inputs must be present. For those
    which are not used a dummy value can be provided.</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>

      <b>POSIT, Nposit</b> <p>
      See <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a><br>
	POSIT is (3,3000), Nposit is a scalar.

    <p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">POSIT = onera_desp_lib_trace_field_line_towards_earth(kext,options,sysaxes,matlabd,x1,x2,x3,maginput,ds)</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'trace_field_line_towards_earth_',&nbsp;
    kext,options,sysaxes,iyear,idoy,ut,&nbsp; x1,x2,x3, maginput, ds,posit,Nposit,&nbsp;
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call trace_field_line_towards_earth1(kext,options,sysaxes,iyear,idoy,ut,
    x1,x2,x3, maginput, ds,posit,Nposit)</font> 
    <p>
        <hr><a name="GET_MLT"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GET_MLT</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to get Magnetic Local Time (MLT) from a Cartesian
    GEO position and date</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>iyr :</b> long integer year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>idoy :</b> long integer day of year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>secs :</b> UT in seconds - double</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>xGEO :</b> 3D array (double) of cartesian position
    in GEO (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>MLT:</b> Magnetic Local Time (hours) - double <b>
    <br />
    </b></font>
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">MLT = onera_desp_lib_get_mlt(matlabd,xGEO)</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'get_mlt_', iyr,idoy,secs,xGEO,MLT,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call get_mlt1(iyr,idoy,secs,xGEO,MLT)</font><br />
    <br />



    <hr><a name="GET_HEMI"></a> 
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GET_HEMI</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
      This routine is deprecated. Use <a href = #GET_HEMI_MULTI>GET_HEMI_MULTI</a> instead.

    <br />


    <hr><a name="GET_HEMI_MULTI"></a> 
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GET_HEMI_MULTI</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">This function computes&nbsp;in which magnetic hemisphere
    is the&nbsp;input location for a set of internal/externalmagnetic field to select.</font>&nbsp;<br />
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>


      <b>ntime, kext, options, sysaxes, iyear, idoy, UT, x1, x2, x3, maginput </b> <p>

      See <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a>


    <p>
                <font face="ARIAL, HELVETICA"><b>IMPORTANT:</b> all inputs must be present. For those
                which are not used a dummy value can be provided.</font> 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>xHEMI:</b>&nbsp;+1 means Northern magnetic hemisphere,
    -1 means Southern magnetic hemisphere, 0 means cannot be defined (magnetic field not
    valid)&nbsp;- long</font>&nbsp;<br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">[xHEMI] = onera_desp_lib_get_hemi(kext,options,sysaxes,matlabd,x1,x2,x3,maginput)</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'get_hemi_multi_idl_',ntime,kext,options,sysaxes,iyear,idoy,ut,
    x1,x2,x3, maginput,xHEMI,&nbsp; /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call GET_HEMI_MULTI(ntime,kext,options,sysaxes,iyear,idoy,ut, x1,x2,x3,
    maginput,xHEMI)</font> 
    <p>
        <br />
    </p>
    <br />



    <hr><a name="LSTAR_PHI"></a> 
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">LSTAR_PHI</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">This function allows one to convert L* to &#934; or
    vice versa</font><font face="ARIAL, HELVETICA">.</font> 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>

      <b>ntime, whichinv, options, iyear, idoy </b> <p>
      See <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a><br>
      NOTE: <b>options</b> does not support user-supplied internal field model.<br>

    <p>
        <font face="ARIAL, HELVETICA"><b>whichinv:</b> long integer to select&nbsp;which conversion
        to perform</font>&nbsp;<br />
    </p>

    <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">1&nbsp;&nbsp; =&nbsp;Lstar
        to &#934;</font>&nbsp;<br />
        <font face="ARIAL, HELVETICA">2&nbsp;&nbsp; =&nbsp;&#934; to Lstar</font><font face="ARIAL, HELVETICA"><span style="FONT-STYLE: italic"> 
        <br />
        </span></font>
    </div>
    <p>
        <font face="ARIAL, HELVETICA"><b>IMPORTANT:</b> all inputs must be present. For those
        which are not used a dummy value can be provided.</font> 
        <br />
        &nbsp; 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS or OUTPUTS (according
        to whichinv):</font></font> 
    </h3>


      <b>Lstar, Phi </b>
      See <a href=#COMMON_ARGUMENTS>Common Argument Definitions</a><br>

    <p>
        <font face="ARIAL, HELVETICA"><b>Phi:</b> &#934;=2&#960;*Bo/Lstar [nT Re<sup>2</sup>]
        (array(GET_IRBEM_NTIME_MAX()) of double)&nbsp;</font> 
        <br />
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"> out = onera_desp_lib_lstar_phi(which,options,matlabd,in) </font>
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, lstar_phi_', ntime,whichinv,options,iyear,idoy,lstar,phi,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call lstar_phi1(ntime,whichinv,options,iyear,idoy,lstar,phi)</font> 
    <br />
    <br />
    <hr><a name="COORDTRANS"></a> 
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">COORD_TRANS</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
	Deprecated. Use <a href = "#COORDTRANSVEC">COORD_TRANS_VEC</a>

       <hr><a name="COORDTRANSVEC"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">COORD_TRANS_VEC</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Generic coordinates transformation from one Earth&nbsp;or
    Heliospheric coordinate system to another&nbsp;</font>&nbsp;<font face="Arial">Earth&nbsp;or
    Heliospheric coordinates system. Handle up to GET_IRBEM_NTIME_MAX() times at once.</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>


      <b>ntime, sysaxesIN, sysaxesOUT, iyr, idoy, secs, xIN</b> <p>

      see <a href=#COMMON_ARGUMENTS>Common Argument
      Definitions</a>
	  <p>
	<font face="ARIAL, HELVETICA"><b>sysaxesIN:</b> long integer&nbsp;indicating input
    coordinates system</font>&nbsp;<br />
    <font face="ARIAL, HELVETICA"><strong>sysaxesOUT :</strong> long integer indicating
    output coordinates system<font face="Times New Roman"> </font>
    <br />
    <font face="ARIAL, HELVETICA"><b>xIN :</b> array (3,NTIME_MAX) of double&nbsp;with position
    in&nbsp;input coordinates system.


	<p>
        <font face="ARIAL, HELVETICA"><b>IMPORTANT:</b> all inputs must be present. For those
        which are not used a dummy value can be provided.</font> 
        <br />
	<p>


    <table style="WIDTH: 627px; HEIGHT: 301px">
        <tbody>
            <tr>
                <td rowspan="1">
                </td>
                <td bgcolor="#c0c0ff">
                    Input</td>
                <td bgcolor="#c0c0ff" rowspan="2">
                    <p align="center">
                        GDZ (0) 
                    </p>
                </td>
                <td bgcolor="#c0c0ff" rowspan="2">
                    <p align="center">
                        GEO (1) 
                    </p>
                </td>
                <td bgcolor="#c0c0ff" rowspan="2">
                    <p align="center">
                        GSM (2) 
                    </p>
                </td>
                <td bgcolor="#c0c0ff" rowspan="2">
                    <p align="center">
                        GSE (3) 
                    </p>
                </td>
                <td bgcolor="#c0c0ff" rowspan="2">
                    <p align="center">
                        SM(4) 
                    </p>
                </td>
                <td bgcolor="#c0c0ff" rowspan="2">
                    <p align="center">
                        GEI(5) 
                    </p>
                </td>
                <td bgcolor="#c0c0ff" rowspan="2">
                    <p align="center">
                        MAG (6) 
                    </p>
                </td>
                <td bgcolor="#c0c0ff" rowspan="2">
                    <p align="center">
                        SPH(7) 
                    </p>
                </td>
                <td bgcolor="#c0c0ff" rowspan="2">
                    <p align="center">
                        RLL(8) 
                    </p>
                </td>
                <td bgcolor="#c0c0ff" rowspan="2">
                    <p align="center">
                        HEE (9) 
                    </p>
                </td>
                <td bgcolor="#c0c0ff" rowspan="2">
                    <p align="center">
                        HAE(10) 
                    </p>
                </td>
                <td bgcolor="#c0c0ff" rowspan="2">
                    <p align="center">
                        HEEQ (11) 
                    </p>
                </td>
            </tr>
            <tr>
                <td bgcolor="#ffff80">
                    Output</td>
                <td>
                </td>
            </tr>
            <tr>
                <td bgcolor="#ffff80" colspan="2">
                    <p align="center">
                        GDZ (0) 
                    </p>
                </td>
                <td bgcolor="#ff8000">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
            </tr>
            <tr>
                <td bgcolor="#ffff80" colspan="2">
                    <p align="center">
                        GEO (1) 
                    </p>
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="#ff8000">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
            </tr>
            <tr>
                <td bgcolor="#ffff80" colspan="2">
                    <p align="center">
                        GSM (2) 
                    </p>
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="#ff8000">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
            </tr>
            <tr>
                <td bgcolor="#ffff80" colspan="2">
                    <p align="center">
                        GSE (3) 
                    </p>
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="#ff8000">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
            </tr>
            <tr>
                <td bgcolor="#ffff80" colspan="2">
                    <p align="center">
                        SM&nbsp;(4) 
                    </p>
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="#ff8000">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
            </tr>
            <tr>
                <td bgcolor="#ffff80" colspan="2">
                    <p align="center">
                        GEI&nbsp;(5) 
                    </p>
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="#ff8000">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
            </tr>
            <tr>
                <td bgcolor="#ffff80" colspan="2">
                    <p align="center">
                        MAG (6) 
                    </p>
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="#ff8000">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
            </tr>
            <tr>
                <td bgcolor="#ffff80" colspan="2">
                    <p align="center">
                        SPH&nbsp;(7) 
                    </p>
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="#ff8000">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
            </tr>
            <tr>
                <td bgcolor="#ffff80" colspan="2">
                    <p align="center">
                        RLL&nbsp;(8) 
                    </p>
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="#ff8000">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
            </tr>
            <tr>
                <td bgcolor="#ffff80" colspan="2">
                    <p align="center">
                        HEE (9) 
                    </p>
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="#ff8000">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
            </tr>
            <tr>
                <td bgcolor="#ffff80" colspan="2">
                    <p align="center">
                        HAE (10) 
                    </p>
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="#ff8000">
                </td>
                <td bgcolor="lime">
                </td>
            </tr>
            <tr>
                <td bgcolor="#ffff80" colspan="2">
                    HEEQ (11)</td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="lime">
                </td>
                <td bgcolor="#ff8000">
                </td>
            </tr>
        </tbody>
    </table>
    <p>
        Table: Available coordinates transformation: <br>
        <input style="WIDTH: 41px; COLOR: black; HEIGHT: 22px; BACKGROUND-COLOR: lime" disabled="disabled" type="text" size="5" />&nbsp;&#8658;Transformation
        implemented
	  <br>
        <input style="WIDTH: 41px; COLOR: black; HEIGHT: 22px; BACKGROUND-COLOR: #ff8000" disabled="disabled" type="text" size="5" />&nbsp;&#8658;Will
        not crash but not very usefull&nbsp;
	  <br>
	  <input style="WIDTH: 41px; COLOR: black; HEIGHT: 22px; BACKGROUND-COLOR: red" disabled="disabled" type="text" size="5" />&nbsp;&#8658;Not
        implemented
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>xOUT :</b> array (3,NTIME_MAX) of double&nbsp;with position
    in&nbsp;output coordinates system. (systems defined by sysaxesOUT)</font>
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="Arial">Y=onera_desp_lib_coord_trans(X,rotation,matlabd)</font>&nbsp;<br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'coord_trans_vec_',
    ntime,sysaxesIN,sysaxesOUT<strong>,</strong>iyr,idoy,secs,xIN,xOUT, /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call coord_trans_vec1(ntime,sysaxesIN,sysaxesOUT<strong>,</strong>iyr,idoy,secs,xIN,xOUT)</font> 
    <p>
    </p>
    <p>
        <hr><a name="GEO2GSM"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GEO2GSM</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">Routine to transform Cartesian GEO to cartesian GSM
        coordinates</font> 
        <br />
        &nbsp; 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>iyr :</b> long integer year</font> 
        <br />
        <font face="ARIAL, HELVETICA"><b>idoy :</b> long integer day of year</font> 
        <br />
        <font face="ARIAL, HELVETICA"><b>secs :</b> UT in seconds - double</font> 
        <br />
        <font face="ARIAL, HELVETICA"><b>xGEO :</b> 3D array (double) of cartesian position
        in GEO (Re)</font> 
        <br />
        &nbsp; 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>psi :</b> angle for GSM coordinate - double <b>
        <br />
        xGSM :</b> 3D array (double) of cartesian position in GSM (Re)</font> 
        <br />
        &nbsp; 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">xGSM = onera_desp_lib_rotate(xGEO,'geo2gsm',matlabd);<br />
        [xGSM,psi] = onera_desp_lib_rotate(xGEO,'geo2gsm',matlabd);</font> 
        <br />
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'geo2gsm_', iyr,idoy,secs,psi,xGEO,xGSM,
        /f_value)</font> 
        <br />
        &nbsp; 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">call geo2gsm1(iyr,idoy,secs,psi,xGEO,xGSM)</font> 
    </p>
    <p>
        <br />
        <br />
        <hr><a name="GSM2GEO"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GSM2GEO</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform Cartesian GSM to cartesian GEO
    coordinates</font> 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>iyr :</b> long integer year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>idoy :</b> long integer day of year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>secs :</b> UT in seconds - double</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>xGSM :</b> 3D array (double) of cartesian position
    in GSM (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>psi :</b> angle for GSM coordinate - double</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>xGEO :</b> 3D array (double) of cartesian position
    in GEO (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">xGEO = onera_desp_lib_rotate(xGSM,'gsm2geo',matlabd);<br />
    [xGEO,psi] = onera_desp_lib_rotate(xGSM,'gsm2geo',matlabd);</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'gsm2geo_', iyr,idoy,secs,psi,xGSM,xGEO,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call gsm2geo1(iyr,idoy,secs,psi,xGSM,xGEO)</font> 
    <p>
        <br />
        <hr><a name="GEO2GSE"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GEO2GSE</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform Cartesian GEO to cartesian GSM
    coordinates</font> 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>iyr :</b> long integer year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>idoy :</b> long integer day of year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>secs :</b> UT in seconds - double</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>xGEO :</b> 3D array (double) of cartesian position
    in GEO (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>xGSE :</b> 3D array (double) of cartesian position
    in GSE (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">xGSE = onera_desp_lib_rotate(xGEO,'geo2gse',matlabd);</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'geo2gse_', iyr,idoy,secs,xGEO,xGSE,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call geo2gse1(iyr,idoy,secs,xGEO,xGSE)</font> 
    <p>
        <br />
        <hr><a name="GSE2GEO"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GSE2GEO</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform Cartesian GSE to cartesian GEO
    coordinates</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>iyr :</b> long integer year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>idoy :</b> long integer day of year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>secs :</b> UT in seconds - double</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>xGSE :</b> 3D array (double) of cartesian position
    in GSE (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>xGEO :</b> 3D array (double) of cartesian position
    in GEO (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">xGEO = onera_desp_lib_rotate(xGSE,'gse2geo',matlabd);</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'gse2geo_', iyr,idoy,secs,xGSE,xGEO,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call gse2geo1(iyr,idoy,secs,xGSE,xGEO)</font> 
    <p>
        <br />
        <hr><a name="GDZ2GEO"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GDZ2GEO</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform GEODEZIC coordinates to cartesian
    GEO coordinates</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>lati :</b> latitude (degres) (double)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>longi :</b> East longitude (degres) (double)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>alti :</b> altitude (km) (double)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>xx :</b> xGEO (Re) (double)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>yy :</b> yGEO (Re) (double)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>zz :</b> zGEO (Re) (double)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">******NOTE ORDER OF GDZ COORDINATES********<br />
    xGEO = onera_desp_lib_rotate([alti(:), lati(:), longi(:)],'gdz2geo');<br />
    xx = xGEO(:,1); yy = xGEO(:,2); zz = xGEO(:,3);</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'gdz2geo_', lati,longi,alti,xx,yy,zz,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call gdz_geo(lati,longi,alti,xx,yy,zz)</font> 
    <p>
        <br />
        <hr><a name="GEO2GDZ"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GEO2GDZ</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform cartesian GEO coordinates to GEODEZIC
    coordinates</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>xx :</b> xGEO (Re) (double)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>yy :</b> yGEO (Re) (double)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>zz :</b> zGEO (Re) (double)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>lati :</b> latitude (degres) (double)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>longi :</b> East longitude (degres) (double)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>alti :</b> altitude (km) (double)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">******NOTE ORDER OF GDZ COORDINATES********<br />
    xGDZ = onera_desp_lib_rotate([xx(:) yy(:) zz(:)],'geo2gdz');<br />
    alti = xGDZ(:,1); lati = xGDZ(:,2); longi = xGDZ(:,3);</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'geo2gdz_', xx,yy,zz,lati,longi,alti,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call geo_gdz(xx,yy,zz,lati,longi,alti)</font> 
    <p>
        <br />
        <hr><a name="GEO2GEI"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GEO2GEI</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform Cartesian GEO to cartesian GEI
    coordinates</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>iyr :</b> long integer year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>idoy :</b> long integer day of year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>secs :</b> UT in seconds -double</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>xGEO :</b> 3D array (double) of cartesian position
    in GEO (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>xGEI:</b> 3D array (double) of cartesian position
    in GEI (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">xGEI = onera_desp_lib_rotate(xGEO,'geo2gei',matlabd);</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'geo2gei_', iyr,idoy,secs,xGEO,xGEI,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call geo2gei1(iyr,idoy,secs,xGEO,xGEI)</font> 
    <p>
        <br />
        <hr><a name="GEI2GEO"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GEI2GEO</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform Cartesian GEI to cartesian GEO
    coordinates</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>iyr :</b> long integer year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>idoy :</b> long integer day of year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>secs :</b> UT in seconds - double</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>xGEI :</b> 3D array (double) of cartesian position
    in GEI (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>xGEO:</b> 3D array (double) of cartesian position
    in GEO (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">xGEO = onera_desp_lib_rotate(xGEI,'gei2geo',matlabd);</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'gei2geo_', iyr,idoy,secs,xGEI,xGEO,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call gei2geo1(iyr,idoy,secs,xGEI,xGEO)</font> 
    <p>
        <br />
        <hr><a name="GEO2SM"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GEO2SM</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform Cartesian GEO to cartesian SM coordinates</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>iyr :</b> long integer year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>idoy :</b> long integer day of year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>secs :</b> UT in seconds - double</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>xGEO :</b> 3D array (double) of cartesian position
    in GEO (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>xSM:</b> 3D array (double) of cartesian position
    in SM (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">xSM = onera_desp_lib_rotate(xGEO,'geo2sm',matlabd);</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'geo2sm_', iyr,idoy,secs,xGEO,xSM,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call geo2sm1(iyr,idoy,secs,xGEO,xSM)</font> 
    <p>
        <br />
        <hr><a name="SM2GEO"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">SM2GEO</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform Cartesian SM to cartesian GEO coordinates</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>iyr :</b> long integer year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>idoy :</b> long integer day of year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>secs :</b> UT in seconds - double</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>xSM :</b> 3D array (double) of cartesian position
    in SM (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>xGEO:</b> 3D array (double) of cartesian position
    in GEO (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">xGEO = onera_desp_lib_rotate(xSM,'sm2geo',matlabd);</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'sm2geo_', iyr,idoy,secs,xSM,xGEO,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call sm2geo1(iyr,idoy,secs,xSM,xGEO)</font> 
    <p>
        <br />
        <hr><a name="GSM2SM"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GSM2SM</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform Cartesian GSM to cartesian SM coordinates</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>iyr :</b> long integer year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>idoy :</b> long integer day of year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>secs :</b> UT in seconds - double</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>xGSM :</b> 3D array (double) of cartesian position
    in GSM (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>xSM:</b> 3D array (double) of cartesian position
    in SM (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">xSM = onera_desp_lib_rotate(xGSM,'gsm2sm',matlabd);</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'gsm2sm_', iyr,idoy,secs,xGSM,xSM,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call gsm2sm1(iyr,idoy,secs,xGSM,xSM)</font> 
    <p>
        <br />
        <hr><a name="SM2GSM"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">SM2GSM</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform Cartesian SM to cartesian GSM coordinates</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>iyr :</b> long integer year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>idoy :</b> long integer day of year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>secs :</b> UT in seconds - double</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>xSM :</b> 3D array (double) of cartesian position
    in SM (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>xGSM:</b> 3D array (double) of cartesian position
    in GSM (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">xGSM = onera_desp_lib_rotate(xSM,'sm2gsm',matlabd);</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'sm2gsm_', iyr,idoy,secs,xSM,xGSM,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call sm2gsm1(iyr,idoy,secs,xSM,xGSM)</font> 
    <p>
        <br />
        <hr><a name="GEO2MAG"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GEO2MAG</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform Cartesian GEO to cartesian MAG
    coordinates</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>iyr :</b> long integer year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>xGEO :</b> 3D array (double) of cartesian position
    in GEO (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>xMAG:</b> 3D array (double) of cartesian position
    in MAG (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">xMAG = onera_desp_lib_rotate(xGEO,'geo2mag',matlabd);</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'geo2mag_', iyr,xGEO,xMAG,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call geo2mag1(iyr,xGEO,xMAG)</font> 
    <p>
        <br />
        <hr><a name="MAG2GEO"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">MAG2GEO</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform Cartesian MAG to cartesian GEO
    coordinates</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>iyr :</b> long integer year</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>xMAG :</b> 3D array (double) of cartesian position
    in MAG (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>xGEO:</b> 3D array (double) of cartesian position
    in GEO (Re)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">xGEO = onera_desp_lib_rotate(xMAG,'mag2geo',matlabd);</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'mag2geo_', iyr,xMAG,xGEO,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call mag2geo1(iyr,xMAG,xGEO)</font> 
    <p>
        <br />
        <hr><a name="EPH2CAR"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">SPH2CAR</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform spherical coordinates to cartesian</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>r :</b> radial distance (double)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>lati:</b> (degree)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>longi:</b> (degree)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>x:</b> 3D array (double) of cartesian position (same
    unit as r)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">xCAR = onera_desp_lib_rotate([r(:), lati(:), longi(:)],'sph2car');</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'sph2car_', r,lati,longi,x,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call SPH_CAR(r,lati,longi,x)</font> 
    <p>
        <br />
        <hr><a name="CAR2EPH"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">CAR2SPH</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform cartesian coordinates to spherical</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>x :</b> 3D array (double) of cartesian position</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>r :</b> radial distance (double) - same unit as x</font> 
    <br />
    <span style="FONT-WEIGHT: bold"><font face="ARIAL, HELVETICA">lati&nbsp;</font></span><font face="ARIAL, HELVETICA"><b>:</b> (degree)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>longi :</b> (degree)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">xSPH = onera_desp_lib_rotate(xCAR,'car2sph');<br />
    r = xSPH(:,1); lati = xSPH(:,2); longi = xSPH(:,3);</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'car2sph_', x,r,lati,longi,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call CAR_SPH(x,r,lati,longi)</font> 
    <p>
        <br />
    </p>
    <p>
        <hr><a name="RLL2GDZ"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">RLL2GDZ</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform radial distance, latitude, longitude
    to altitude, latitude, longitude</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>r :</b> radial distance (double) - Re</font> 
    <br />
    <span style="FONT-WEIGHT: bold"><font face="ARIAL, HELVETICA">lati&nbsp;</font></span><font face="ARIAL, HELVETICA"><b>:</b> (double-
    degree)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>longi :</b> (</font><font face="ARIAL, HELVETICA">double- </font><font face="ARIAL, HELVETICA">degree)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>alti :</b> altitude (double) - km</font> 
    <br />
    <span style="FONT-WEIGHT: bold"></span>
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">******NOTE ORDER OF GDZ COORDINATES********<br />
    xGDZ = onera_desp_lib_rotate([r(:), lati(:), longi(:)],'rll2gdz');<br />
    alti = xGDZ(:,1); lati = xGDZ(:,2); longi = xGDZ(:,3);</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'rll2gdz_', r,lati,longi,alti,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call RLL_GDZ(r,lati,longi,alti)</font> 
    <br />
    <p>
        <br />
        <hr><a name="GSE2HEE"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GSE2HEE</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform geocentric coordinates GSE to heliospheric
    coordinates HEE (Heliocentric Earth Ecliptic also sometime known as Heliospheric Solar
    Ecliptic (HSE) </font>
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>iyr :</b> year (long)&nbsp;</font> 
    <br />
    <span style="FONT-WEIGHT: bold"><font face="ARIAL, HELVETICA">idoy</font></span><font face="ARIAL, HELVETICA"><b>:</b> day
    of year - January 1st is idoy=1 (long)</font>&nbsp;<br />
    <font face="ARIAL, HELVETICA"><b>UT :</b> Universal Time (double- seconds)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>xGSE :</b> 3D array (double) of cartesian position
    in GSE (Re)</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>xHEE :</b> 3D array (double) of cartesian position
    in HEE (AU)</font> 
    <br />
    <span style="FONT-WEIGHT: bold"></span>
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">xHEE = onera_desp_lib_rotate(xGSE,'gse2hee',matlabd);</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'gse2hee_', iyr,idoy,UT,xGSE,xHEE,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call gse2hee1(iyr,idoy,UT,xGSE,xHEE)</font> 
    <br />
    <p>
        <br />
        <hr><a name="HEE2GSE"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">HEE2GSE</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform heliospheric coordinates HEE (Heliocentric
    Earth Ecliptic also sometime known as Heliospheric Solar Ecliptic (HSE) to geocentric
    coordinates GSE</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>iyr :</b> year (long)&nbsp;</font> 
    <br />
    <span style="FONT-WEIGHT: bold"><font face="ARIAL, HELVETICA">idoy</font></span><font face="ARIAL, HELVETICA"><b>:</b> day
    of year - January 1st is idoy=1 (long)</font>&nbsp;<br />
    <font face="ARIAL, HELVETICA"><b>UT :</b> Universal Time (double- seconds)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>xHEE :</b> 3D array (double) of cartesian position
    in HEE (AU)</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>xGSE :</b> 3D array (double) of cartesian position
    in GSE (Re)</font> 
    <br />
    <span style="FONT-WEIGHT: bold"></span>
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">xGSE = onera_desp_lib_rotate(xHEE,'hee2gse',matlabd);</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'hee2gse_', iyr,idoy,UT,xHEE,xGSE,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call hee2gse1(iyr,idoy,UT,xHEE,xGSE)</font> 
    <br />
    <p>
        <br />
        <hr><a name="HEE2HAE"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">HEE2HAE</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform heliospheric coordinates HEE (Heliocentric
    Earth Ecliptic also sometime known as Heliospheric Solar Ecliptic (HSE) to heliospheric
    coordinates HAE (Heliocentric Aries Ecliptic also sometime known as Heliospheric Solar
    Ecliptic (HSE)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>iyr :</b> year (long)&nbsp;</font> 
    <br />
    <span style="FONT-WEIGHT: bold"><font face="ARIAL, HELVETICA">idoy</font></span><font face="ARIAL, HELVETICA"><b>:</b> day
    of year - January 1st is idoy=1 (long)</font>&nbsp;<br />
    <font face="ARIAL, HELVETICA"><b>UT :</b> Universal Time (double- seconds)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>xHEE :</b> 3D array (double) of cartesian position
    in HEE (AU)</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>xHAE :</b> 3D array (double) of cartesian position
    in HAE (AU)</font> 
    <br />
    <span style="FONT-WEIGHT: bold"></span>
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">xHAE = onera_desp_lib_rotate(xHEE,'hee2hae',matlabd);</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'hee2hae_', iyr,idoy,UT,xHEE,xHAE,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call hee2hae1(iyr,idoy,UT,xHEE,xHAE)</font> 
    <br />
    <p>
        <br />
        <hr><a name="HAE2HEE"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">HAE2HEE</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform heliospheric coordinates HAE (Heliocentric
    Aries Ecliptic also sometime known as Heliospheric Solar Ecliptic (HSE) to heliospheric
    coordinates HEE (Heliocentric Earth Ecliptic also sometime known as Heliospheric Solar
    Ecliptic (HSE)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>iyr :</b> year (long)&nbsp;</font> 
    <br />
    <span style="FONT-WEIGHT: bold"><font face="ARIAL, HELVETICA">idoy</font></span><font face="ARIAL, HELVETICA"><b>:</b> day
    of year - January 1st is idoy=1 (long)</font>&nbsp;<br />
    <font face="ARIAL, HELVETICA"><b>UT :</b> Universal Time (double- seconds)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>xHAE :</b> 3D array (double) of cartesian position
    in HAE (AU)</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>xHEE :</b> 3D array (double) of cartesian position
    in HEE (AU)</font> 
    <br />
    <span style="FONT-WEIGHT: bold"></span>
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">xHEE = onera_desp_lib_rotate(xHAE,'hae2hee',matlabd);</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'hae2hee_', iyr,idoy,UT,xHAE,xHEE,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call hae2hee1(iyr,idoy,UT,xHAE,xHEE)</font> 
    <br />
    <p>
        <br />
        <hr><a name="HAE2HEEQ"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">HAE2HEEQ</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform heliospheric coordinates HAE (Heliocentric
    Aries Ecliptic also sometime known as Heliospheric Solar Ecliptic (HSE) to heliospheric
    coordinates HEEQ (Heliocentric Earth Equatorial also sometime known as Heliospheric
    Solar (HS)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>iyr :</b> year (long)&nbsp;</font> 
    <br />
    <span style="FONT-WEIGHT: bold"><font face="ARIAL, HELVETICA">idoy</font></span><font face="ARIAL, HELVETICA"><b>:</b> day
    of year - January 1st is idoy=1 (long)</font>&nbsp;<br />
    <font face="ARIAL, HELVETICA"><b>UT :</b> Universal Time (double- seconds)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>xHAE :</b> 3D array (double) of cartesian position
    in HAE (AU)</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>xHEEQ :</b> 3D array (double) of cartesian position
    in HEEQ (AU)</font> 
    <br />
    <span style="FONT-WEIGHT: bold"></span>
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">xHEEQ = onera_desp_lib_rotate(xHAE,'hae2heeq',matlabd);</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'hae2heeq_', iyr,idoy,UT,xHAE,xHEEQ,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call hae2heeq1(iyr,idoy,UT,xHAE,xHEEQ)</font> 
    <br />
    <p>
        <br />
        <hr><a name="HEEQ2HAE"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">HEEQ2HAE</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Routine to transform heliospheric coordinates HEEQ (Heliocentric
    Earth Equatorial also sometime known as Heliospheric Solar (HS) to heliospheric coordinates
    HAE (Heliocentric Aries Ecliptic also sometime known as Heliospheric Solar Ecliptic
    (HSE)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>iyr :</b> year (long)&nbsp;</font> 
    <br />
    <span style="FONT-WEIGHT: bold"><font face="ARIAL, HELVETICA">idoy</font></span><font face="ARIAL, HELVETICA"><b>:</b> day
    of year - January 1st is idoy=1 (long)</font>&nbsp;<br />
    <font face="ARIAL, HELVETICA"><b>UT :</b> Universal Time (double- seconds)</font> 
    <br />
    <font face="ARIAL, HELVETICA"><b>xHEEQ :</b> 3D array (double) of cartesian position
    in HEEQ (AU)</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>xHAE :</b> 3D array (double) of cartesian position
    in HAE (AU)</font> 
    <br />
    <span style="FONT-WEIGHT: bold"></span>
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">xHAE = onera_desp_lib_rotate(xHEEQ,'heeq2hae',matlabd);</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'heeq2hae_', iyr,idoy,UT,xHEEQ,xHAE,
    /f_value)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call heeq2hae1(iyr,idoy,UT,xHEEQ,xHAE)</font> 
    <br />
    <p>
        <br />
        <hr><a name="JULDAY"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">JULDAY</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Calculate the Julian Day Number for a given month, day,
    and year.</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>MONTH:</b> Number of the desired month (1 = January,
    ..., 12 = December). - long</font> 
    <p>
        <font face="ARIAL, HELVETICA"><b>DAY:</b> Number of day of the month. - long</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>YEAR:</b> Number of the desired year.Year parameters
        must be valid values from the civil calendar. Years B.C.E. are represented as negative
        integers. Years in the common era are represented as positive integers. In particular,
        note that there is no year 0 in the civil calendar. 1 B.C.E. (-1) is followed by 1
        C.E. (1). - long</font> 
        <br />
        &nbsp; 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>JULDAY</b> returns the Julian Day Number (which begins
    at noon) of the specified calendar date. - long</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Not available, see MATLAB build-in routines</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Not available, see IDL build-in routines</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Result = JULDAY(Year,Month, Day)</font> 
    <p>
        <br />
        <hr><a name="CALDAT"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">CALDAT</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Return the calendar date given julian day. This is the
    inverse of the function JULDAY.</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>JULIAN</b> contains the Julian Day Number (which
    begins at noon) of the specified calendar date. It should be a long integer.</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>MONTH:</b> Number of the desired month (1 = January,
    ..., 12 = December). - long</font> 
    <p>
        <font face="ARIAL, HELVETICA"><b>DAY:</b> Number of day of the month. - long</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>YEAR:</b> Number of the desired year. - long</font> 
        <br />
        &nbsp; 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Not available, see MATLAB build-in routines</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Not available, see IDL build-in routines</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">CALL CALDAT(julian, year,month, day)</font> 
    <p>
        <br />
        <hr><a name="GET_DOY"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GET_DOY</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Calculate the day of year for a given month, day, and
    year.</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>MONTH:</b> Number of the desired month (1 = January,
    ..., 12 = December).</font> 
    <p>
        <font face="ARIAL, HELVETICA"><b>DAY:</b> Number of day of the month.</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>YEAR:</b> Number of the desired year.Year parameters
        must be valid values from the civil calendar. Years B.C.E. are represented as negative
        integers. Years in the common era are represented as positive integers. In particular,
        note that there is no year 0 in the civil calendar. 1 B.C.E. (-1) is followed by 1
        C.E. (1).</font> 
        <br />
        &nbsp; 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>GET_DOY</b> returns the day of year of the specified
    calendar date.</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Not available, see MATLAB build-in routines</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Not available, see IDL build-in routines</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Result = GET_DOY(Year,Month, Day)</font> 
    <p>
        <br />
        <hr><a name="DECY2DATE_AND_TIME"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">DECY2DATE_AND_TIME</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Calculate the date and time (yea,month,day of month,
    day of year, hour, minute and second and Universal Time)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>DEC_Y :</b> Decimal year where yyyy.0d0 is January
    1st at 00:00:00 - double</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>YEAR:</b> Number year.Year parameters must be valid
    values from the civil calendar. Years B.C.E. are represented as negative integers.
    Years in the common era are represented as positive integers. In particular, note
    that there is no year 0 in the civil calendar. 1 B.C.E. (-1) is followed by 1 C.E.
    (1). - long</font> 
    <p>
        <font face="ARIAL, HELVETICA"><b>MONTH:</b> Number month (1 = January, ..., 12 = December).
        - long</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>DAY:</b> Number of day of the month. - long</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>DOY:</b> Number of day of year (DOY=1 is for January
        1st) - long</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>HOUR, MINUTE and SECOND:</b> Universal time in the
        day - long</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>UT:</b> Univeral time in seconds - double</font> 
        <br />
        &nbsp; 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Not available, see MATLAB build-in routines</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Not available, see IDL build-in routines</font> 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">CALL DECY2DATE_AND_TIME(Dec_y,Year,Month, Day, doy,
    hour,minute,second,UT)</font> 
    <p>
        <br />
        &nbsp; <hr><a name="DATE_AND_TIME2DECY"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">DATE_AND_TIME2DECY</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Calculate the decimal year from date and time (yea,month,day
    of month, hour, minute and second)</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>YEAR:</b> Number year.Year parameters must be valid
    values from the civil calendar. Years B.C.E. are represented as negative integers.
    Years in the common era are represented as positive integers. In particular, note
    that there is no year 0 in the civil calendar. 1 B.C.E. (-1) is followed by 1 C.E.
    (1). - long</font> 
    <p>
        <font face="ARIAL, HELVETICA"><b>MONTH:</b> Number month (1 = January, ..., 12 = December).
        - long</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>DAY:</b> Number of day of the month. - long</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>HOUR, MINUTE and SECOND:</b> Universal time in the
        day - long</font> 
    </p>
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>DEC_Y :</b> Decimal year where yyyy.0d0 is January
    1st at 00:00:00 - double<br />
    </font><font face="ARIAL, HELVETICA"><b>
    <br />
    </b></font> 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Not available, see MATLAB build-in routines</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Not available, see IDL build-in routines</font> 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">CALL DATE_AND_TIME2DECY(Year,Month,Day,hour,minute,second,Dec_y)</font><br />
    <br />
    <br />
    &nbsp; <hr><a name="DOY_AND_UT2DATE_AND_TIME"></a> 
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">DOY_AND_UT2DATE_AND_TIME</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Calculate month, day, year from year and day of year<br />
    Calculate time (hour, minute, second) from UT</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>YEAR:</b> Number year.Year parameters must be valid
    values from the civil calendar. Years B.C.E. are represented as negative integers.
    Years in the common era are represented as positive integers. In particular, note
    that there is no year 0 in the civil calendar. 1 B.C.E. (-1) is followed by 1 C.E.
    (1). - long</font> 
    <p>
        <font face="ARIAL, HELVETICA"><b>DOY:</b> Number of day of year (DOY=1 is for January
        1st) - long</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>UT:</b> Universal time in seconds -&nbsp;double</font> 
    </p>
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>Month&nbsp;:</b> Number month (1 = January, ...,
        12 = December). - long</font> 
    </p>
    <p>
        <strong>Day&nbsp;:</strong> Number of day of the month - long 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>HOUR, MINUTE and SECOND:</strong> Universal
        time in the day - long 
        <br /><br />
        </font>
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Not available, see MATLAB build-in routines</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Not available, see IDL build-in routines</font> 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">CALL DOY_AND_UT2DATE_AND_TIME(Year,Doy,UT,Month, Day,
    hour,minute,second)</font><br />
    <br />
    <br />
    <br />
    <br />
    <p>
        <hr><a name="FLY_IN_NASA_AEAP"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">FLY_IN_NASA_AEAP</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">This function allows one to fly any spacecraft in NASA
    AE8 min/max and AP8 min/max models</font><font face="ARIAL, HELVETICA">.<br />
    The output can be differential flux or flux within an energy range or integral flux.<br />
    </font> 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>ntime:</b> long integer number of time in arrays
    (max allowed is GET_IRBEM_NTIME_MAX())</font> 
    <p>
        <font face="ARIAL, HELVETICA"><b>sysaxes:</b> long integer to define which coordinate
        system is provided in</font> 
        <br />
    </p>
    <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">0: GDZ (alti, lati, East
        longi - km,deg.,deg)</font> 
        <br />
        <font face="ARIAL, HELVETICA">1: GEO (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">2: GSM (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">3: GSE (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">4: SM (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">5: GEI (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">6: MAG (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">7: SPH (geo in spherical) - (radial distance, lati,
        East longi - Re, deg., deg.)<br />
        </font><font face="ARIAL, HELVETICA">8: RLL&nbsp; (radial distance, lati, East longi
        - Re, deg., deg. - prefered to 7)</font> 
        <br />
    </div>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>whichm:</b> long integer to select in which NASA
        model to fly<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px">
	<TABLE>
	<TR><TH>whichm</TH><TH></TH><TH align=left>Model</TH></TR>
	<TR><TD align=right>1</TD><TD>=</TD><TD>AE8 MIN</TD></TR>
	<TR><TD align=right>2</TD><TD>=</TD><TD>AE8 MAX</TD></TR>
	<TR><TD align=right>3</TD><TD>=</TD><TD>AP8 MIN</TD></TR>
	<TR><TD align=right>4</TD><TD>=</TD><TD>AP8 MAX</TD></TR>
	<TR><TD align=right>-1</TD><TD>=</TD><TD>AE8 MIN - ESA Interpolation</TD></TR>
	<TR><TD align=right>-2</TD><TD>=</TD><TD>AE8 MAX - ESA Interpolation</TD></TR>
	<TR><TD align=right>-3</TD><TD>=</TD><TD>AP8 MIN - ESA Interpolation</TD></TR>
	<TR><TD align=right>-4</TD><TD>=</TD><TD>AP8 MAX - ESA Interpolation</TD></TR>
	</TABLE>
	<br>
      <i>The ESA Interpolation scheme provides for better flux interpolations at low altitudes.</br>
      See: E. J. Daly, et al., "Problems with models of the radiation belts",<br>
      IEEE Trans. Nucl. Sci, Vol 43, No. 2, Apr. 1996. DOI 10.1109/23.490889<br></i>
    </div>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>whatf:</b> long integer to select what flux to compute<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px">1=differential flux (MeV<sup>-1</sup> cm<sup>-2</sup> s<sup>-1</sup>)
        at energy(1,*)<br />
        2=flux within an ernergy range (MeV<sup>-1</sup> cm<sup>-2</sup> s<sup>-1</sup>) -
        energy(1,*) to energy(2,*)<br />
        3=integral flux (cm<sup>-2</sup> s<sup>-1</sup>) at energy(1,*) 
    </div>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>Nene:</strong> long integer number of&nbsp;energies
        in array energy&nbsp;(max allowed is 25) </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>energy:</b> array(2,25) of double. If whatf=1 or
        3 then energy(2,*) is not considered.<br />
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <span style="FONT-STYLE: italic">Note: if energy is
        in MeV then differential flux will be per MeV.</span> 
        <br />
        </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>iyear:</b> array(GET_IRBEM_NTIME_MAX()) of long integer year when&nbsp;positions
        are given. Can be a dummy value for the following sysaxes values: 0,1,6,7,8.<br />
        </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>idoy:</b> array(GET_IRBEM_NTIME_MAX()) of long integer doy when
        positions are given. Can be a dummy value for the following sysaxes values: 0,1,6,7,8.</font>&nbsp; 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>UT:</b> array(GET_IRBEM_NTIME_MAX()) of double, UT in seconds when
        positions are given. Can be a dummy value for the following sysaxes values: 0,1,6,7,8</font>&nbsp; 
    </p>
    <p>
    </p>
    <font face="ARIAL, HELVETICA"><b>x1:</b> array(GET_IRBEM_NTIME_MAX()) of double, first coordinate
    according to sysaxes. If sysaxes is 0 then altitude has to be in km otherwise use
    dimensionless variables (in Re)</font> 
    <p>
        <font face="ARIAL, HELVETICA"><b>x2:</b> array(GET_IRBEM_NTIME_MAX()) of double, second coordinate
        according to sysaxes. If sysaxes is 0 then latitude has to be in degrees otherwise
        use dimensionless variables (in Re)</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>x3:</b> array(GET_IRBEM_NTIME_MAX()) of double, third coordinate
        according to sysaxes. If sysaxes is 0 then East longitude has to be in degrees otherwise
        use dimensionless variables (in Re).</font> 
    </p>
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>flux:</b> flux according to selection of whatf for
    all times and energies (array(GET_IRBEM_NTIME_MAX(),25) of double)</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Flux = onera_desp_lib_fly_in_nasa_aeap(sysaxes,whichm,energy,matlabd,x1,x2,x3)</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'fly_in_nasa_aeap_',
    ntime,sysaxes,whichm,whatf,Nene,energy,iyear,idoy, UT,x1,x2,x3,flux, /f_value)</font> 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">CALL </font><font face="ARIAL, HELVETICA">fly_in_nasa_aeap1</font><font face="ARIAL, HELVETICA">(</font><font face="ARIAL, HELVETICA">ntime,sysaxes,whichm,whatf,Nene,energy,iyear,idoy,
    UT,x1,x2,x3,flux)</font><br />
    <br />
    <br />
    <p>
        <hr><a name="GET_AE8_AP8_FLUX"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GET_AE8_AP8_FLUX</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">This function allows one to&nbsp;compute NASA AE8 min/max
        and AP8 min/max flux for any B/Bo, L position</font><font face="ARIAL, HELVETICA">.<br />
        The output can be differential flux or flux within an energy range or integral flux.<br />
        </font>
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>ntime:</b> long integer number of&nbsp;points in
        arrays (max allowed is GET_IRBEM_NTIME_MAX())</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>whichm:</b> long integer to select in which NASA
        model to fly<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px">
	<TABLE>
	<TR><TH>whichm</TH><TH></TH><TH align=left>Model</TH></TR>
	<TR><TD align=right>1</TD><TD>=</TD><TD>AE8 MIN</TD></TR>
	<TR><TD align=right>2</TD><TD>=</TD><TD>AE8 MAX</TD></TR>
	<TR><TD align=right>3</TD><TD>=</TD><TD>AP8 MIN</TD></TR>
	<TR><TD align=right>4</TD><TD>=</TD><TD>AP8 MAX</TD></TR>
	<TR><TD align=right>-1</TD><TD>=</TD><TD>AE8 MIN - ESA Interpolation</TD></TR>
	<TR><TD align=right>-2</TD><TD>=</TD><TD>AE8 MAX - ESA Interpolation</TD></TR>
	<TR><TD align=right>-3</TD><TD>=</TD><TD>AP8 MIN - ESA Interpolation</TD></TR>
	<TR><TD align=right>-4</TD><TD>=</TD><TD>AP8 MAX - ESA Interpolation</TD></TR>
	</TABLE>
	<br>
      <i>The ESA Interpolation scheme provides for better flux interpolations at low altitudes.</br>
      See: E. J. Daly, et al., "Problems with models of the radiation belts",<br>
      IEEE Trans. Nucl. Sci, Vol 43, No. 2, Apr. 1996. DOI 10.1109/23.490889<br></i>
    </div>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>whatf:</b> long integer to select what flux to compute<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px">1=differential flux (MeV<sup>-1</sup> cm<sup>-2</sup> s<sup>-1</sup>)
        at energy(1,*)<br />
        2=flux within an ernergy range (MeV<sup>-1</sup> cm<sup>-2</sup> s<sup>-1</sup>) -
        energy(1,*) to energy(2,*)<br />
        3=integral flux (cm<sup>-2</sup> s<sup>-1</sup>) at energy(1,*) 
    </div>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>Nene:</strong> long integer number of&nbsp;energies
        in array energy&nbsp;(max allowed is 25) </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>energy:</b> array(2,25) of double. If whatf=1 or
        3 then energy(2,*) is not considered.<br />
        &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <span style="FONT-STYLE: italic">Note: if energy is
        in MeV then differential flux will be per MeV.</span> 
        <br />
        </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>BBo:</b> array(GET_IRBEM_NTIME_MAX()) of double. Provide B/Bequator
        for all position where to compute the fluxes. Note that the Jensen and Cain 1960 magnetic
        field model must be used for any call to AE8min, AE8max, AP8min and GSFC 1266 (extended
        to year 1970) for any call to AP8max.<br />
        </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>L:</b> array(GET_IRBEM_NTIME_MAX()) of double. Provide McIlwain
        L for all position where to compute the fluxes.</font>&nbsp; Note that the Jensen
        and Cain 1960 magnetic field model must be used for any call to AE8min, AE8max, AP8min
        and GSFC 1266 (extended to year 1970) for any call to AP8max.<br />
    </p>
    <p>
        <br />
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>flux:</b> flux according to selection of whatf for
        all times and energies (array(GET_IRBEM_NTIME_MAX(),25) of double)</font> 
        <br />
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">Flux = onera_desp_lib_get_ae8_ap8_flux(whichm,energy,BBo,L)</font> 
        <br />
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'get_ae8_ap8_flux_idl_',
        ntime,whichm,whatf,Nene,energy,BBo,L,,flux, /f_value)</font> 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">CALL </font><font face="ARIAL, HELVETICA">get_ae8_ap8_flux</font> <font face="ARIAL, HELVETICA">(</font><font face="ARIAL, HELVETICA">ntime,whichm,whatf,Nene,energy,BBo,L,flux</font> <font face="ARIAL, HELVETICA">)<br />
        <br />
        </font>&nbsp;<br />
    <br />
        <hr>
    </p>
    <a name="FLY_IN_AFRL_CRRES"></a> 
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">FLY_IN_AFRL_CRRES</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">This function allows one to fly any spacecraft in AFRL
        CRRESPRO and CRRESELE models</font><font face="ARIAL, HELVETICA">.<br />
        The output can be differential flux or flux within an energy range or integral flux.</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA">Caution: integral flux for electron are from E to&nbsp;
        5.75 MeV and for proton are from E to 81.3 MeV.</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA">To run CRRES models you have to set the full path for
        the source code directory (where CRRES data files are located).<br />
        </font>
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>ntime:</b> long integer number of time in arrays
    (max allowed is GET_IRBEM_NTIME_MAX())</font> 
    <p>
        <font face="ARIAL, HELVETICA"><b>sysaxes:</b> long integer to define which coordinate
        system is provided in</font> 
        <br />
    </p>
    <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">0: GDZ (alti, lati, East
        longi - km,deg.,deg)</font> 
        <br />
        <font face="ARIAL, HELVETICA">1: GEO (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">2: GSM (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">3: GSE (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">4: SM (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">5: GEI (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">6: MAG (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">7: SPH (geo in spherical) - (radial distance, lati,
        East longi - Re, deg., deg.)<br />
        </font><font face="ARIAL, HELVETICA">8: RLL&nbsp; (radial distance, lati, East longi
        - Re, deg., deg. - prefered to 7)</font> 
        <br />
    </div>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>whichm:</b> long integer to select in which&nbsp;AFRL
        CRRES&nbsp;model to fly<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px">1=CRRESPRO QUIET<br />
        2=CRRESPRO ACTIVE<br />
        3=CRRESELE AVERAGE<br />
        4=CRRESELE WORST CASE 
    </div>
    <div style="MARGIN-LEFT: 40px">5=CRRESELE Ap15<br />
    </div>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>whatf:</b> long integer to select what flux to compute<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px">1=differential flux (MeV<sup>-1</sup> cm<sup>-2</sup> s<sup>-1</sup>)
        at energy(1,*)<br />
        2=flux within an ernergy range (MeV<sup>-1</sup> cm<sup>-2</sup> s<sup>-1</sup>) -
        energy(1,*) to energy(2,*)<br />
        3=integral flux (cm<sup>-2</sup> s<sup>-1</sup>) at energy(1,*) 
    </div>
    <p>
    </p>
    <font face="ARIAL, HELVETICA"><b>Nene:</b> long integer number of&nbsp;energies in
    array energy&nbsp;(max allowed is 25) </font> 
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>energy:</b> array(2,25) of double (MeV). If whatf=1
        or 3 then energy(2,*) is not considered.<br />
        </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>iyear:</b> array(GET_IRBEM_NTIME_MAX()) of long integer year when&nbsp;positions
        are given. Can be a dummy value for the following sysaxes values: 0,1,6,7,8.<br />
        </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>idoy:</b> array(GET_IRBEM_NTIME_MAX()) of long integer doy when
        positions are given. Can be a dummy value for the following sysaxes values: 0,1,6,7,8.</font>&nbsp; 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>UT:</b> array(GET_IRBEM_NTIME_MAX()) of double, UT in seconds when
        positions are given. Can be a dummy value for the following sysaxes values: 0,1,6,7,8.</font>&nbsp; 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>x1:</b> array(GET_IRBEM_NTIME_MAX()) of double, first coordinate
        according to sysaxes. If sysaxes is 0 then altitude has to be in km otherwise use
        dimensionless variables (in Re) </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>x2:</b> array(GET_IRBEM_NTIME_MAX()) of double, second coordinate
        according to sysaxes. If sysaxes is 0 then latitude has to be in degrees otherwise
        use dimensionless variables (in Re)</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>x3:</b> array(GET_IRBEM_NTIME_MAX()) of double, third coordinate
        according to sysaxes. If sysaxes is 0 then longitude has to be in degrees otherwise
        use dimensionless variables (in Re).</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>Ap15:</b> array(GET_IRBEM_NTIME_MAX()) of double, preceding 15-day
        running average of Ap index assuming a one day delay. Array can be set to 0 if whichm
        non equal to 5. </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>path:</b> byte array where the number of elements
        is the length of the string to be converted to byte, provides the path to locate&nbsp;the
        files which describe CRRES models. Note that the path should end by a "/" or "\" depending
        on your operating system. Before submitting the path it must me converted to byte
        array where each element is the ascii code for the corresponding character in the
        path.</font>&nbsp; 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>path_len:</b> long integer, provide here the length
        of the path string</font> 
    </p>
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>flux:</b> flux according to selection of whatf for
    all times and energies (array(GET_IRBEM_NTIME_MAX(),25) of double)</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Flux = onera_desp_lib_fly_in_afrl_crres(sysaxes,whichm,energy,matlabd,x1,x2,x3,Ap15,crres_path)</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'fly_in_afrl_crres_',
    ntime,sysaxes,whichm,whatf,Nene,energy,iyear,idoy, UT,x1,x2,x3,Ap15,flux,path,path_len,
    /f_value)</font> 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">CALL </font><font face="ARIAL, HELVETICA">fly_in_afrl_crres1</font><font face="ARIAL, HELVETICA">(</font><font face="ARIAL, HELVETICA">ntime,sysaxes,whichm,whatf,Nene,energy,iyear,idoy,
        UT,x1,x2,x3,Ap15,flux,path,path_len</font><font face="ARIAL, HELVETICA">)</font> 
    </p>
    <p>
    </p>
    <p>
        <hr> <a name="GET_CRRES_FLUX"></a>
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GET_CRRES_FLUX</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">This function allows one to compute AFRL CRRESPRO and
        CRRESELE flux for any B/Bo, L position</font><font face="ARIAL, HELVETICA">.<br />
        The output can be differential flux or flux within an energy range or integral flux.</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA">Caution: integral flux for electron are from E to&nbsp;
        5.75 MeV and for proton are from E to 81.3 MeV.</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA">To run CRRES models you have to set the full path for
        the source code directory (where CRRES data files are located).<br />
        </font>
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>ntime:</b> long integer number of&nbsp;points in
        arrays (max allowed is GET_IRBEM_NTIME_MAX())</font> 
    </p>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>whichm:</b> long integer to select in which&nbsp;AFRL
        CRRES&nbsp;model to fly<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px">1=CRRESPRO QUIET<br />
        2=CRRESPRO ACTIVE<br />
        3=CRRESELE AVERAGE<br />
        4=CRRESELE WORST CASE 
    </div>
    <div style="MARGIN-LEFT: 40px">5=CRRESELE Ap15<br />
    </div>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>whatf:</b> long integer to select what flux to compute<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px">1=differential flux (MeV<sup>-1</sup> cm<sup>-2</sup> s<sup>-1</sup>)
        at energy(1,*)<br />
        2=flux within an ernergy range (MeV<sup>-1</sup> cm<sup>-2</sup> s<sup>-1</sup>) -
        energy(1,*) to energy(2,*)<br />
        3=integral flux (cm<sup>-2</sup> s<sup>-1</sup>) at energy(1,*) 
    </div>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>Nene:</b> long integer number of&nbsp;energies in
        array energy&nbsp;(max allowed is 25) </font>
    </p>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>energy:</b> array(2,25) of double (MeV). If whatf=1
        or 3 then energy(2,*) is not considered.<br />
        </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>BBo:</b> array(GET_IRBEM_NTIME_MAX()) of double. Provide B/Bequator
        for all position where to compute the fluxes. Note that the IGRF1985 magnetic field
        model must be used.<br />
        </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>L:</b> array(GET_IRBEM_NTIME_MAX()) of double. Provide McIlwain
        L for all position where to compute the fluxes.&nbsp; Note that the IGRF1985 magnetic
        field model must be used.</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>Ap15:</b> array(GET_IRBEM_NTIME_MAX()) of double, preceding 15-day
        running average of Ap index assuming a one day delay. Array can be set to 0 if whichm
        non equal to 5. </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>path:</b> byte array where the number of elements
        is the length of the string to be converted to byte, provides the path to locate&nbsp;the
        files which describe CRRES models. Note that the path should end by a "/" or "\" depending
        on your operating system. Before submitting the path it must me converted to byte
        array where each element is the ascii code for the corresponding character in the
        path.</font>&nbsp; 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>path_len:</b> long integer, provide here the length
        of the path string</font> 
    </p>
    <p>
        <br />
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>flux:</b> flux according to selection of whatf for
        all times and energies (array(GET_IRBEM_NTIME_MAX(),25) of double)</font> 
        <br />
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">Flux = onera_desp_lib_get_crres_flux(whichm,energy,BBo,L,Ap15,crres_path)</font> 
        <br />
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'get_crres_flux_idl_',
        ntime,whichm,whatf,Nene,energy,BBo,L,Ap15,flux,path,path_len, /f_value)</font> 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">CALL </font><font face="ARIAL, HELVETICA">get_crres_flux</font><font face="ARIAL, HELVETICA">(</font><font face="ARIAL, HELVETICA">ntime,whichm,whatf,Nene,energy,BBo,L,Ap15,flux,path,path_len</font><font face="ARIAL, HELVETICA">)</font> 
    </p>
    <p>
       <hr>
    </p>
    <a name="FLY_IN_IGE"></a> 
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">FLY_IN_IGE</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">This function allows one to fly any geostationary spacecraft
        in&nbsp;IGE (International Geostationary Electron)&nbsp;models</font><font face="ARIAL, HELVETICA">.
        The use of the model is limited to geostationary altitude as it is based on LANL-GEO&nbsp;
        bird series (1976 to 2006) and JAXA-DRTS spacecraft (added in IGE2006). Three versions
        of the model are provided: </font>
    </p>
    <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">1: known as POLE-V1, it&nbsp;covers electron energies
        from 30 keV-1.3 MeV (issued in 2003) <br>
        Published in <em>Boscher D., S. Bourdarie, R. Friedel
        and D. Belian, A model for the geostationary electron environment : POLE, IEEE Trans.
        Nuc. Sci., 50 (6), 2278-2283, Dec. 2003</em>. <br>

        <br />
        2: known as POLE-V2, it&nbsp;covers electron energies from 30 keV-5.2 MeV (issued
        in 2005) <br>
        Published in <em>Sicard-Piet A., S. Bourdarie, Boscher
        D. and&nbsp;R. Friedel, A model for the geostationary electron environment : POLE
        from 30 keV to 5.2 MeV, IEEE Trans. Nuc. Sci., 53 (4), 1844-1850, Aug. 2006</em>. <br>
        <br />
        3: known as&nbsp;IGE-2006, it&nbsp;covers electron energies from&nbsp;0.9 keV-5.2
        MeV (issued in 2006) <br>
        Submitted in <em>Sicard-Piet A., S. Bourdarie, Boscher
        D.,&nbsp;R. Friedel M. Thomsen, T. Goka, H. Matsumoto, H. Koshiishi, A new international
        geostationary model:&nbsp;IGE-2006 from&nbsp;1 keV to 5.2 MeV, JGR-Space Weather,
        2007</em>.<br /></font>
        <br />
    </div>
    <p>
        <font face="ARIAL, HELVETICA"><em>Note that POLE stands for Particle-ONERA-LANL-Electrons</em></font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"></font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA">The output can be differential flux or flux within an
        energy range or integral flux.</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA">Caution: integral flux for electron are from E to Emax
        of the given&nbsp;selected model. So one should be very carrefull when looking at
        integral fluxes with POLE-V1&nbsp;.</font> <font face="ARIAL, HELVETICA">
        <br />
        </font>
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>launch_year:</b> year of spacecraft start of life
        in space - long integer</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>mission_duration:</b> duration of the mission (number
        of years) - long integer</font> 
        <br />
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>whichm:</b> long integer to select in which&nbsp;IGE
        model to fly<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">1=POLE-V1<br />
        2=POLE-V2<br />
        3=IGE-2006<br />
        <br /></font>
    </div>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>whatf:</b> long integer to select what flux to compute<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">1=differential flux (MeV<sup>-1</sup> cm<sup>-2</sup> s<sup>-1</sup> sr<sup>-1</sup>)
        at energy(1,*)<br />
        2=flux within an ernergy range (MeV<sup>-1</sup> cm<sup>-2</sup> s<sup>-1</sup> sr<sup>-1</sup>)
        - energy(1,*) to energy(2,*)<br />
        3=integral flux (cm<sup>-2</sup> s<sup>-1</sup> sr<sup>-1</sup>) at energy(1,*) </font>
    </div>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>Nene:</b> long integer number of&nbsp;energies in
        array energy&nbsp;(max allowed is 50). If Nene&nbsp;=0 then a default energy grid
        is being used. The number of default channels is then returned in Nene.&nbsp;</font> 
    </p>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>energy:</b> array(2,50) of double (MeV). If whatf=1
        or 3 then energy(2,*) is not considered. If Nene=0 then the default energies are returned
        (in energy(1,1:Nene) in fortran or in energy(0,0:Nene-1)).<br />
        </font>
    </p>
    <p>
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>Lower_flux:</b> Lower flux according to selection
        of whatf for all energies averaged over entire mission duration - This has to be considered
        as a lower envelop&nbsp;to bound&nbsp;expected flux at GEO for any solar cycle (array(50)
        of double) </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>Mean_flux:</b>&nbsp;Mean flux according to selection of whatf for all energies
        averaged over entire mission duration - This&nbsp;spectrum is an averaged&nbsp;expected
        flux at GEO for any solar cycle , no margins are included at this point(array(50)
        of double) </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>Upper_flux:</b>&nbsp;Upper flux according to selection of whatf for all energies
        averaged over entire mission duration - This has to be considered as an upper envelop
        for expected flux at GEO for any solar cycle, this spectrum can be used for any conservative
        approach as margins are included at this point. Note that the margins are enrgy depended
        and can be assesed by&nbsp;looking at Upper_flux/Mean_flux&nbsp;(array(50) of double) </font>
    </p>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA">Note: all flux are expressed in MeV<sup>-1</sup> cm<sup>-2</sup> s<sup>-1</sup> sr<sup>-1</sup> for
        differential flux&nbsp;or in cm<sup>-2</sup> s<sup>-1</sup> sr<sup>-1</sup> for
        integrated flux.&nbsp;To derive omnidirectional flux at GEO one should multiply these
        flux values by 4&#960;. </font>
    </p>
    <p>
        <br />
        &nbsp; 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">[Lower_flux,Mean_flux,Upper_flux] = onera_desp_lib_fly_in_ige(launch_year,mission_duration,whichm,whatf,energy)</font> 
        <br />
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'fly_in_ige_', launch_year,mission_duration,whichm,whatf,Nene,energy,Lower_flux,Mean_flux,Upper_flux,
        /f_value)</font> 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">CALL </font><font face="ARIAL, HELVETICA">fly_in_ige1</font><font face="ARIAL, HELVETICA">(</font><font face="ARIAL, HELVETICA">launch_year,mission_duration,whichm,whatf,Nene,energy,Lower_flux,Mean_flux,Upper_flux</font><font face="ARIAL, HELVETICA">)</font> 
    </p>
    <p>
        <br />
    </p>
    <p>
        <hr>
    </p>
    <a name="FLY_IN_MEO_GNSS"></a> 
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">FLY_IN_MEO_GNSS</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">This function allows one to fly any MEO GNSS type spacecraft
        in&nbsp;MEO ONERA models.
        The use of the model is limited to GPS altitude (~20000 km - 55 inclination) as it is based on LANL-GPS&nbsp;
        bird series (1990 to 2006). Two versions of the model are provided: </font>
    </p>
    <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">1: known as MEO-V1, it&nbsp;covers electron energies
        from 280 keV-1.12 MeV (issued in 2006). Note that in this model there is no solar cycle variations
        which is to say that the model should be used for long term studies on the order of a solar cycle duration (i.e.
        11 years). </font>
    </div>
    <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">Published in <em>Sicard-Piet A., S. Bourdarie,D. Boscher, R. Friedel
        and T. Cayton, Solar cycle electron environment at GNSS like altitudes, IAC-06-D5.2.04,2006.</em>. <br>
        <br />
        2: known as MEO-V2, it&nbsp;covers electron energies from 280 keV-2.24 MeV (issued
        in 2007) </font>
    </div>
    <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">Not published yet. </font>
    </div>
    <br>
    <br>
    <p>
        <font face="ARIAL, HELVETICA">The output can be differential flux or flux within an
        energy range or integral flux.</font> 
    </p>
    <br>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>launch_year:</b> year of spacecraft start of life
        in space - long integer</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>mission_duration:</b> duration of the mission (number
        of years) - long integer</font> 
        <br />
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>whichm:</b> long integer to select in which&nbsp;MEO
        model to fly<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px">
        1=MEO-V1<br />
        2=MEO-V2<br />
        <br />
    </div>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>whatf:</b> long integer to select what flux to compute<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">1=differential flux (MeV<sup>-1</sup> cm<sup>-2</sup> s<sup>-1</sup> sr<sup>-1</sup>)
        at energy(1,*)<br />
        2=flux within an ernergy range (MeV<sup>-1</sup> cm<sup>-2</sup> s<sup>-1</sup> sr<sup>-1</sup>)
        - energy(1,*) to energy(2,*)<br />
        3=integral flux (cm<sup>-2</sup> s<sup>-1</sup> sr<sup>-1</sup>) at energy(1,*) </font>
    </div>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>Nene:</b> long integer number of&nbsp;energies in
        array energy&nbsp;(max allowed is 50). If Nene&nbsp;=0 then a default energy grid
        is being used. The number of default channels is then returned in Nene.&nbsp;</font> 
    </p>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>energy:</b> array(2,50) of double (MeV). If whatf=1
        or 3 then energy(2,*) is not considered. If Nene=0 then the default energies are returned
        (in energy(1,1:Nene) in fortran or in energy(0,0:Nene-1)).<br />
        </font>
    </p>
    <p>
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>Lower_flux:</b> Lower flux according to selection
        of whatf for all energies averaged over entire mission duration - This has to be considered
        as a lower envelop&nbsp;to bound&nbsp;expected flux at MEO-GNSS for any solar cycle (array(50)
        of double) </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>Mean_flux:</b>&nbsp;Mean flux according to selection of whatf for all energies
        averaged over entire mission duration - This&nbsp;spectrum is an averaged&nbsp;expected
        flux at MEO-GNSS for any solar cycle , no margins are included at this point(array(50)
        of double) </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>Upper_flux:</b>&nbsp;Upper flux according to selection of whatf for all energies
        averaged over entire mission duration - This has to be considered as an upper envelop
        for expected flux at MEO-GNSS for any solar cycle, this spectrum can be used for any conservative
        approach as margins are included at this point. Note that the margins are enrgy depended
        and can be assesed by&nbsp;looking at Upper_flux/Mean_flux&nbsp;(array(50) of double) </font>
    </p>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA">Note: all flux are expressed in MeV<sup>-1</sup> cm<sup>-2</sup> s<sup>-1</sup> sr<sup>-1</sup> for
        differential flux&nbsp;or in cm<sup>-2</sup> s<sup>-1</sup> sr<sup>-1</sup> for
        integrated flux.&nbsp;To derive omnidirectional flux at MEO-GNSS one should multiply these
        flux values by 4&#960;. </font>
    </p>
    <p>
        <br />
        &nbsp; 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">[Lower_flux,Mean_flux,Upper_flux] = onera_desp_lib_fly_in_meo_gnss(launch_year,mission_duration,whichm,energy)</font> 
        <br />
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'fly_in_meo_gnss_', launch_year,mission_duration,whichm,whatf,Nene,energy,Lower_flux,Mean_flux,Upper_flux,
        /f_value)</font> 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">CALL </font><font face="ARIAL, HELVETICA">fly_in_meo_gnss1</font><font face="ARIAL, HELVETICA">(</font><font face="ARIAL, HELVETICA">launch_year,mission_duration,whichm,whatf,Nene,energy,Lower_flux,Mean_flux,Upper_flux</font><font face="ARIAL, HELVETICA">)</font> 
    </p>
    <p>
        <br />
    </p>
    <p>
        <hr><a name="MSIS86"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">MSIS86</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">The Mass-Spectrometer-Incoherent-Scatter-1986 (MSIS-86)
        neutral atmosphere model describes the neutral temperature and the densities of He,
        O, N2, O2, Ar, H, and N. The MSIS model is based on the extensive data compilation
        and analysis work of A. E. Hedin and his collaborators [A. E. Hedin et al., J. Geophys.
        Res. 82, 2139-2156, 1977; A. E. Hedin, J. Geophys. Res. 88, 10170- 10188, 1983; A.
        E. Hedin, J. Geophys. Res. 92, 4649, 1987]. MSIS-86 constitutes the upper part of
        the COSPAR International Reference Atmosphere (CIRA-86). </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA">Data sources for the present model include temperature
        and density measurements from several rockets, satellites (OGO-6, San Marco 3, Aeros-A,
        AE-C, AE-D, AE-E, ESRO 4 and DE-2) and incoherent scatter radars (Millstone Hill,
        St. Santin, Arecibo, Jicamarca, and Malvern). Since the MSIS-83 model, terms were
        added or changed to better represent seasonal variations in the polar regions under
        both quiet and magnetically disturbed conditions and local time variations in the
        magnetic activity effect. In addition a new species, atomic nitrogen, was added to
        the list of species covered by the model. </font>
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>Ntime:</b> long integer number of time in arrays
        (max allowed is GET_IRBEM_NTIME_MAX())</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>WhichAp:</b> long integer</font> to select the&nbsp;kind
        of Ap input:<br />
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <div style="MARGIN-LEFT: 40px">1=Only daily Ap magnetic index is provided in Ap array
        (i.e. 1st element)<br />
        2=All fields in Ap array are provided (i.e. the 7th elements)<br />
    </div>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>DOY:</b> array(GET_IRBEM_NTIME_MAX()) of long integer, Number of
        day of year (DOY=1 is for January 1st) </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>UT:</strong> array(GET_IRBEM_NTIME_MAX()) of double, UT in
        seconds when positions are given..</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>Alt:</strong> array(GET_IRBEM_NTIME_MAX()) of double, Altitude
        in km (greater than 85 km).</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>Lat:</strong> array(GET_IRBEM_NTIME_MAX()) of double, Geodetic
        latitude (Deg.)</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>Long:</strong> array(GET_IRBEM_NTIME_MAX()) of double, Geodetic
        longitude (Deg.)</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>F107A:</strong> array(GET_IRBEM_NTIME_MAX()) of double, 3 month
        average of F10.7 flux.</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>F107:</strong> array(GET_IRBEM_NTIME_MAX()) of double, daily
        F10.7 flux for previous day.</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>Ap:</b> array(7,GET_IRBEM_NTIME_MAX()) of double where:<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px">1st element=Daily Ap<br />
        2nd element=3 hours Ap index for current time<br />
        3rd element=3 hours Ap index for 3 hours before current time 
        <br />
        4th element=3 hours Ap index for 6 hours before current time<br />
        5th element=3 hours Ap index for 9 hours before current time<br />
        6th element=Average of eight 3 hours Ap indices from 12 to 33 hours prior to current
        time<br />
        7th element=Average of eight 3 hours Ap indices from 36 to 59 hours prior to current
        time 
    </div>
    <p>
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>Dens:</b> array(8,GET_IRBEM_NTIME_MAX()) of double where:<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">Dens(1st element,*)=He number density (cm<sup>-3</sup>) 
    </font></div>
    <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">Dens(2nd element,*)=O number density (cm<sup>-3</sup>)<br />
        Dens(3rd&nbsp;element,*)=N<sub>2</sub> number density (cm<sup>-3</sup>)<br />
        Dens(4th&nbsp;element,*)=O<sub>2</sub> number density (cm<sup>-3</sup>)<br />
        Dens(5th element,*)=AR number density (cm<sup>-3</sup>)<br />
        Dens(6th element,*)=Total mass density (g/cm<sup>-3</sup>)<br />
        Dens(7th element,*)=H number density (cm<sup>-3</sup>)<br />
        Dens(8th element,*)=N number density (cm<sup>-3</sup>) </font>
    </div>
    <p>
        <font face="ARIAL, HELVETICA"><b>Temp:</b> array(2,GET_IRBEM_NTIME_MAX()) of double where:<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px">Temp(1st element,*)=Exospheric temperature (K) 
    </div>
    <div style="MARGIN-LEFT: 40px">Temp(2nd element,*)=Temperature at alt (K)&nbsp; 
    </div>
    <p>
    </p>
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">out = onera_desp_lib_msis('msis86',date,X,sysaxes,F107A,F107,Ap)</font> 
        <br />
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'msis86_idl_', ntime,whichAp,DOY,UT,Alt,Lat,Lon,F107A,F107,Ap,Dens,Temp,
        /f_value)</font> 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">CALL </font><font face="ARIAL, HELVETICA">msis86</font><font face="ARIAL, HELVETICA">(</font><font face="ARIAL, HELVETICA">ntime,whichAp,DOY,UT,Alt,Lat,Lon,F107A,F107,Ap,Dens,Temp</font><font face="ARIAL, HELVETICA">)</font> 
    </p>
    <p>
        <br />
    </p>
    <p>
        <hr><a name="MSISE90"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">MSISE90</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">The MSISE model describes the neutral temperature and
        densities in Earth's atmosphere from ground to thermospheric heights. Below 72.5 km
        the model is primarily based on the MAP Handbook (Labitzke et al., 1985) tabulation
        of zonal average temperature and pressure by Barnett and Corney, which was also used
        for the CIRA-86. Below 20 km these data were supplemented with averages from the National
        Meteorological Center (NMC). In addition, pitot tube, falling sphere, and grenade
        sounder rocket measurements from 1947 to 1972 were taken into consideration. Above
        72.5 km MSISE-90 is essentially a revised MSIS-86 model taking into account data derived
        from space shuttle flights and newer incoherent scatter results. For someone interested
        only in the thermosphere (above 120 km), the author recommends the MSIS-86 model.
        MSISE is also not the model of preference for specialized tropospheric work. It is
        rather for studies that reach across several atmospheric boundaries. </font>
    </p>
    <p>
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>Ntime:</b> long integer number of time in arrays
        (max allowed is GET_IRBEM_NTIME_MAX())</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>WhichAp:</b> long integer</font> to select the&nbsp;kind
        of Ap input:<br />
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <div style="MARGIN-LEFT: 40px">1=Only daily Ap magnetic index is provided in Ap array
        (i.e. 1st element)<br />
        2=All fields in Ap array are provided (i.e. the 7th elements)<br />
    </div>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>DOY:</b> array(GET_IRBEM_NTIME_MAX()) of long integer, Number of
        day of year (DOY=1 is for January 1st) </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>UT:</strong> array(GET_IRBEM_NTIME_MAX()) of double, UT in
        seconds when positions are given..</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>Alt:</strong> array(GET_IRBEM_NTIME_MAX()) of double, Altitude
        (km).</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>Lat:</strong> array(GET_IRBEM_NTIME_MAX()) of double, Geodetic
        latitude (Deg.)</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>Long:</strong> array(GET_IRBEM_NTIME_MAX()) of double, Geodetic
        longitude (Deg.)</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>F107A:</strong> array(GET_IRBEM_NTIME_MAX()) of double, 3 month
        average of F10.7 flux.</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>F107:</strong> array(GET_IRBEM_NTIME_MAX()) of double, daily
        F10.7 flux for previous day.</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>Ap:</b> array(7,GET_IRBEM_NTIME_MAX()) of double where:<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px">1st element=Daily Ap<br />
        2nd element=3 hours Ap index for current time<br />
        3rd element=3 hours Ap index for 3 hours before current time 
        <br />
        4th element=3 hours Ap index for 6 hours before current time<br />
        5th element=3 hours Ap index for 9 hours before current time<br />
        6th element=Average of eight 3 hours Ap indices from 12 to 33 hours prior to current
        time<br />
        7th element=Average of eight 3 hours Ap indices from 36 to 59 hours prior to current
        time 
    </div>
    <p>
    </p>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"></font>
    </p>
    <p>
    </p>
    <font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    <p>
        <font face="ARIAL, HELVETICA"><b>Dens:</b> array(8,GET_IRBEM_NTIME_MAX()) of double where:<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px">Dens(1st element,*)=He number density (cm<sup>-3</sup>) 
    </div>
    <div style="MARGIN-LEFT: 40px">Dens(2nd element,*)=O number density (cm<sup>-3</sup>)<br />
        Dens(3rd&nbsp;element,*)=N<sub>2</sub> number density (cm<sup>-3</sup>)<br />
        Dens(4th&nbsp;element,*)=O<sub>2</sub> number density (cm<sup>-3</sup>)<br />
        Dens(5th element,*)=AR number density (cm<sup>-3</sup>)<br />
        Dens(6th element,*)=Total mass density (g/cm<sup>-3</sup>)<br />
        Dens(7th element,*)=H number density (cm<sup>-3</sup>)<br />
        Dens(8th element,*)=N number density (cm<sup>-3</sup>) 
    </div>
    <p>
        <font face="ARIAL, HELVETICA"><b>Temp:</b> array(2,GET_IRBEM_NTIME_MAX()) of double where:<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px">Temp(1st element,*)=Exospheric temperature (K) 
    </div>
    <div style="MARGIN-LEFT: 40px">Temp(2nd element,*)=Temperature at alt (K)&nbsp; 
    </div>
    <p>
    </p>
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">out = onera_desp_lib_msis('msise90',date,X,sysaxes,F107A,F107,Ap)</font> 
        <br />
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'msise90_idl_', ntime,whichAp,DOY,UT,Alt,Lat,Lon,F107A,F107,Ap,Dens,Temp,
        /f_value)</font> 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">CALL </font><font face="ARIAL, HELVETICA">msise90</font><font face="ARIAL, HELVETICA">(</font><font face="ARIAL, HELVETICA">ntime,whichAp,DOY,UT,Alt,Lat,Lon,F107A,F107,Ap,Dens,Temp</font><font face="ARIAL, HELVETICA">)</font> 
    </p>
    <p>
        <br />
    </p> 
    <p>
        <hr><a name="NRLMSIS00"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">NRLMSIS00</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">The NRLMSIS-00 empirical atmosphere model was developed
        by Mike Picone, Alan Hedin, and Doug Drob based on the MSISE90 model. The main differences
        to MSISE90 are noted in the comments at the top of the computer code. They involve
        (1) the extensive use of drag and accelerometer data on total mass density, (2) the
        addition of a component to the total mass density that accounts for possibly significant
        contributions of O+ and hot oxygen at altitudes above 500 km, and (3) the inclusion
        of the SMM UV occultation data on [O2]. The MSISE90 model describes the neutral temperature
        and densities in Earth's atmosphere from ground to thermospheric heights. Below 72.5
        km the model is primarily based on the MAP Handbook (Labitzke et al., 1985) tabulation
        of zonal average temperature and pressure by Barnett and Corney, which was also used
        for the CIRA-86. Below 20 km these data were supplemented with averages from the National
        Meteorological Center (NMC). In addition, pitot tube, falling sphere, and grenade
        sounder rocket measurements from 1947 to 1972 were taken into consideration. Above
        72.5 km MSISE-90 is essentially a revised MSIS-86 model taking into account data derived
        from space shuttle flights and newer incoherent scatter results. For someone interested
        only in the thermosphere (above 120 km), the author recommends the MSIS-86 model.
        MSISE is also not the model of preference for specialized tropospheric work. It is
        rather for studies that reach across several atmospheric boundaries. </font>
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>Ntime:</b> long integer number of time in arrays
        (max allowed is GET_IRBEM_NTIME_MAX())</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>WhichAp:</b> long integer to select the&nbsp;kind
        of Ap input:<br /></font>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">1=Only daily Ap magnetic index is provided in Ap array
        (i.e. 1st element)<br />
        2=All fields in Ap array are provided (i.e. the 7th elements)<br /></font>
    </div>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>DOY:</b> array(GET_IRBEM_NTIME_MAX()) of long integer, Number of
        day of year (DOY=1 is for January 1st) </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>UT:</strong> array(GET_IRBEM_NTIME_MAX()) of double, UT in
        seconds when positions are given..</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>Alt:</strong> array(GET_IRBEM_NTIME_MAX()) of double, Altitude
        in km (greater than 85 km).</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>Lat:</strong> array(GET_IRBEM_NTIME_MAX()) of double, Geodetic
        latitude (Deg.)</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>Long:</strong> array(GET_IRBEM_NTIME_MAX()) of double, Geodetic
        longitude (Deg.)</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>F107A:</strong> array(GET_IRBEM_NTIME_MAX()) of double, 3 month
        average of F10.7 flux.</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>F107:</strong> array(GET_IRBEM_NTIME_MAX()) of double, daily
        F10.7 flux for previous day.</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>Ap:</b> array(7,GET_IRBEM_NTIME_MAX()) of double where:<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px">1st element=Daily Ap<br />
        2nd element=3 hours Ap index for current time<br />
        3rd element=3 hours Ap index for 3 hours before current time 
        <br />
        4th element=3 hours Ap index for 6 hours before current time<br />
        5th element=3 hours Ap index for 9 hours before current time<br />
        6th element=Average of eight 3 hours Ap indices from 12 to 33 hours prior to current
        time<br />
        7th element=Average of eight 3 hours Ap indices from 36 to 59 hours prior to current
        time 
    </div>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
    </p>
    <font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    <p>
        <font face="ARIAL, HELVETICA"><b>Dens:</b> array(9,GET_IRBEM_NTIME_MAX()) of double where:<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">Dens(1st element,*)=He number density (cm<sup>-3</sup>) 
    </font></div>
    <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">Dens(2nd element,*)=O number density (cm<sup>-3</sup>)<br />
        Dens(3rd&nbsp;element,*)=N<sub>2</sub> number density (cm<sup>-3</sup>)<br />
        Dens(4th&nbsp;element,*)=O<sub>2</sub> number density (cm<sup>-3</sup>)<br />
        Dens(5th element,*)=AR number density (cm<sup>-3</sup>)<br />
        Dens(6th element,*)=Total mass density (g/cm<sup>-3</sup>)<br />
        Dens(7th element,*)=H number density (cm<sup>-3</sup>)<br />
        Dens(8th element,*)=N number density (cm<sup>-3</sup>) 
        <br />
        Dens(9th element,*)=Anomalous oxygen&nbsp;number density (cm<sup>-3</sup>) 
    </font></div>
    <p>
        <font face="ARIAL, HELVETICA"><b>Temp:</b> array(2,GET_IRBEM_NTIME_MAX()) of double where:<br />
        </font>
    </p>
    <div style="MARGIN-LEFT: 40px">Temp(1st element,*)=Exospheric temperature (K) 
    </div>
    <div style="MARGIN-LEFT: 40px">Temp(2nd element,*)=Temperature at alt (K)&nbsp; 
    </div>
    <p>
    </p>
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <p>
        <font face="Arial">out = onera_desp_lib_msis('nrlmsise00',date,X,sysaxes,F107A,F107,Ap)</font>&nbsp;<br />
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'nrlmsise00_idl_',
        ntime,whichAp,DOY,UT,Alt,Lat,Lon,F107A,F107,Ap,Dens,Temp, /f_value)</font> 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">CALL </font><font face="ARIAL, HELVETICA">nrlmsise00</font><font face="ARIAL, HELVETICA">(</font><font face="ARIAL, HELVETICA">ntime,whichAp,DOY,UT,Alt,Lat,Lon,F107A,F107,Ap,Dens,Temp</font><font face="ARIAL, HELVETICA">)</font> 
    </p>
    <p>
        <br />
    </p>
    <p>
        <hr><a name="SGP4_TLE"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">SGP4_TLE</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">SGP4 stands for Simplified General Perturbation -4 and
        consists in an orbit propagator. This function allows one to propagate NORAD two lines
        elements (TLE sets can be found at <a href="http://celestrak.com/">http://celestrak.com/</a>).
        More about SGP4 can be found at: <a href="http://celestrak.com/NORAD/documentation/spacetrk.pdf">http://celestrak.com/NORAD/documentation/spacetrk.pdf</a> and
        at <a href="http://www.centerforspace.com/downloads/files/pubs/AIAA 2006-6753 Revisiting Spacetrack Report 3.pdf">http://www.centerforspace.com/downloads/files/pubs/AIAA
        2006-6753 Revisiting Spacetrack Report 3.pdf</a></font> 
    </p>
    <p>
        Important notice: those who are running the library on Unix or linux system have to
        convert TLE files from NORAD from DOS to UNIX using the command : dos2unix file.tle
        newfile.tle . Also be aware that some&nbsp;TLE files contains random errors, like
        elements from another satellite, repeated elements, ... there are no specific filters
        implemented in the SGP4 function. 
    </p>
    <p>
        For those who are familiar with SGP4 code, be aware for one difference between orginal
        SGP4 code and the one provided here: input start and stop time and time step are not
        in minutes but in seconds. This was chosen for convenience. 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"></font>
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>runtype:</b> long integer&nbsp;to select&nbsp;in
        which mode&nbsp;SGP4_TLE will run</font>&nbsp; 
    </p>
    <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">0: defines start and
        stop time to propagate each TLE according to input file</font>&nbsp;<br />
        <font face="ARIAL, HELVETICA">1:&nbsp;propagates each TLE according to user start
        and stop time</font>&nbsp; 
        <br />
    </div>
    <p>
        <font face="ARIAL, HELVETICA"><b>startsfe:</b> double giving start time in seconds
        from date provided in each TLE. This number can be negative.</font> Note that this
        value is not use if runtype is equal to 0. 
    </p>
    <p>
        <strong>stopsfe:</strong> double giving stop time in seconds from date provided in
        each TLE. This number can be negative. Note that this value is not use if runtype
        is equal to 0.<br />
        <br />
        <strong>deltasec:</strong> double giving&nbsp;step time in seconds to propagateTLE. 
    </p>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>InFileByte:</b> byte array where the number of elements
        is the length of the string to be converted to byte, provides the path and name&nbsp;to
        locate&nbsp;the input TLE to be propagated.&nbsp;Before submitting the path it must
        me converted to byte array where each element is the ascii code for the corresponding
        character in the path.</font>&nbsp; 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>strlenIn:</b> long integer providing the length of
        InFileByte string</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>OutFileByte:</b> byte array where the number of elements
        is the length of the string to be converted to byte, provides the path and name&nbsp;to
        locate&nbsp;the output file.&nbsp;Before submitting the path it must me converted
        to byte array where each element is the ascii code for the corresponding character
        in the path.</font>&nbsp; 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>strlenOut:</b> long integer providing here the length
        of OutFileByte string</font>&nbsp;<br />
        &nbsp; 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>None:</b>&nbsp;They are provided in OutFileByte.
        This file is composed of 6 columns:</font>&nbsp;<br />
    </p>
    <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">1:&nbsp;date (dd/mm/yyyy)</font>&nbsp;<br />
        <font face="ARIAL, HELVETICA">2:&nbsp;time (hh:mm:ss)</font> 
    </div>
    <div style="MARGIN-LEFT: 40px">3: decimal year 
    </div>
    <div style="MARGIN-LEFT: 40px">4: altitude (km) 
    </div>
    <div style="MARGIN-LEFT: 40px">5: latitude (deg) 
    </div>
    <div style="MARGIN-LEFT: 40px">6: East longitude (deg)&nbsp; 
        <br />
    </div>
    <p>
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <p>
        The Matlab wrapper handles calculation of runtype strlenIn, OutfileByte, strlenOut.
        OutfileByte and strlenOut will be set appropriately for a temporary file (onera_desp_lib_sgp4_tle.tmp
        or onera_desp_lib_sgp4_tle.tmp.####). The wrapper reads the library routine's output
        from the temporary file and passes it back as a Matlab structure. The temporary file
        is deleted, so the Matlab structure is the only result of a successful call to sgp4_tle.
        In order to avoid a memory overflow for very long TLE runs, it is possible to leave
        the output in a text file (as in the FORTRAN call): the syntax is then onera_desp_lib_sgp4_tle(InFile,OutFile) 
    </p>
    <p>
        pos = onera_desp_lib_sgp4_tle(InFileByte) %implies runtype=0<br />
    </p>
    <p>
        pos = onera_desp_lib_sgp4_tle(startsfe,stopsfe,deltasec,InFileByte) %implies runtype=1<br />
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'sgp4_tle_', runtype,startsfe,stopsfe,deltasec,InFileByte,strlenIn,OutFileByte,strlenOut,
        /f_value)</font> 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">CALL </font><font face="ARIAL, HELVETICA">sgp4_tle1</font><font face="ARIAL, HELVETICA">(</font><font face="ARIAL, HELVETICA">runtype,startsfe,stopsfe,deltasec,InFileByte,strlenIn,OutFileByte,strlenOut</font><font face="ARIAL, HELVETICA">)<br />
        <br />
        </font>&nbsp;<hr><a name="SGP4_ORB"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">SGP4_ELE</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">SGP4 stands for Simplified General Perturbation -4 and
        consists in an orbit propagator. This function allows one to produce orbit coordinates
        from different types of orbital elements... More about SGP4 can be found at: <a href="http://celestrak.com/NORAD/documentation/spacetrk.pdf">http://celestrak.com/NORAD/documentation/spacetrk.pdf</a> and
        at <a href="http://www.centerforspace.com/downloads/files/pubs/AIAA 2006-6753 Revisiting Spacetrack Report 3.pdf">http://www.centerforspace.com/downloads/files/pubs/AIAA
        2006-6753 Revisiting Spacetrack Report 3.pdf</a></font> 
    </p>
    <p>
        For those who are familiar with SGP4 code, be aware for one difference between orginal
        SGP4 code and the one provided here: input start and stop time and time step are not
        in minutes but in seconds. This was chosen for convenience. 
    </p>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"></font>
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>sysaxesOUT:</b> long integer to define which coordinate
        system is provided out</font> 
        <br />
    </p>
    <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">0: GDZ (alti, lati, East
        longi - km,deg.,deg)</font> 
        <br />
        <font face="ARIAL, HELVETICA">1: GEO (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">2: GSM (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">3: GSE (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">4: SM (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">5: GEI (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">6: MAG (cartesian) - Re</font> 
        <br />
        <font face="ARIAL, HELVETICA">7: SPH (geo in spherical) - (radial distance, lati,
        East longi - Re, deg., deg.)<br />
        </font><font face="ARIAL, HELVETICA">8: RLL&nbsp; (radial distance, lati, East longi
        - Re, deg., deg. - prefered to 7)</font> 
        <br />
    </div> 
    <p>
        <font face="ARIAL, HELVETICA"><strong>year:</strong> long integer&nbsp;giving start
        year of start date</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>month:</strong> long integer&nbsp;giving start
        month of start date </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>day:</strong> long integer&nbsp;giving start
        day of month of start date. </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>hour:</strong> long integer&nbsp;giving start&nbsp;hour
        of start time. </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>minute:</strong> long integer&nbsp;giving start&nbsp;minute
        of start time. </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>sec:</strong> double giving start&nbsp;seconds
        of start time. </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>e1:</strong> double see detailed definition
        according to options array. </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>e2:</strong> double see detailed definition
        according to options array. </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>e2:</strong> double see detailed definition
        according to options array. </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>e4:</strong> double see detailed definition
        according to options array. </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>e5:</strong> double see detailed definition
        according to options array. </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>e6:</strong> double see detailed definition
        according to options array. </font>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>options:</b> array(5) of long integer to define which&nbsp;type
        of element&nbsp;is provided in</font> 
        <br />
        <font style="MARGIN-LEFT: 40px" face="ARIAL, HELVETICA">Case options(1st element)
        of:</font> 
        <br />
        <br />
    </p>
    <div style="MARGIN-LEFT: 80px"><font face="ARIAL, HELVETICA">1:&nbsp;ONERA type elements:&nbsp;</font> 
        <br />
        <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">e1 = Inclination - deg </font>
            <br />
            <font face="ARIAL, HELVETICA">e2 = geocentric altitude of perigee - km</font> 
            <br />
            <font face="ARIAL, HELVETICA">e3 = geocentric altitude of apogee - km</font> 
            <br />
            <font face="ARIAL, HELVETICA">e4 = longitude of the ascending node - deg</font> 
            <br />
            <font face="ARIAL, HELVETICA">Case options(2nd element) of:</font> 
            <br />
            <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">1:&nbsp;e5 = argument
                of perigee - deg</font> 
                <br />
                <font face="ARIAL, HELVETICA">2:&nbsp;e5 = longitude of perigee - deg</font> 
                <br />
            </div>
            <font face="ARIAL, HELVETICA">Case options(3rd element) of:</font> 
            <br />
            <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">1:&nbsp;e6 = time since
                perigee passage - sec</font> 
                <br />
                <font face="ARIAL, HELVETICA">2:&nbsp;e6 = true anomaly at epoch - deg</font> 
                <br />
                <font face="ARIAL, HELVETICA">3:&nbsp;e6 = argument of latitude at epoch - deg</font> 
                <br />
                <font face="ARIAL, HELVETICA">4:&nbsp;e6 = true longitude at epoch - deg</font> 
                <br />
                <font face="ARIAL, HELVETICA">5:&nbsp;e6 = mean anomaly at epoch - deg</font> 
                <br />
            </div>
        </div>
        <br />
        <font face="ARIAL, HELVETICA">2:&nbsp;Classical type elements:</font>&nbsp;<br />
        <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">e1 = semimajor axis -
            Re </font>
            <br />
            <font face="ARIAL, HELVETICA">e2 = eccentricity</font> 
            <br />
            <font face="ARIAL, HELVETICA">e3 = inclination - deg</font> 
            <br />
            <font face="ARIAL, HELVETICA">e4 = longitude of ascending node - deg</font> 
            <br />
            <font face="ARIAL, HELVETICA">Case options(2nd element) of:</font> 
            <br />
            <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">1:&nbsp;e5 = argument
                of perigee - deg</font> 
                <br />
                <font face="ARIAL, HELVETICA">2:&nbsp;e5 = longitude of perigee - deg</font> 
                <br />
            </div>
            <font face="ARIAL, HELVETICA">Case options(3rd element) of:</font> 
            <br />
            <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">1:&nbsp;e6 = time since
                perigee passage - sec</font> 
                <br />
                <font face="ARIAL, HELVETICA">2:&nbsp;e6 = true anomaly at epoch - deg</font> 
                <br />
                <font face="ARIAL, HELVETICA">3:&nbsp;e6 = argument of latitude at epoch - deg</font> 
                <br />
                <font face="ARIAL, HELVETICA">4:&nbsp;e6 = true longitude at epoch - deg</font> 
                <br />
                <font face="ARIAL, HELVETICA">5:&nbsp;e6 = mean anomaly at epoch - deg</font> 
                <br />
            </div>
        </div>
        <br />
        <font face="ARIAL, HELVETICA">3:&nbsp;RV type elements:</font>&nbsp;<br />
        <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">e1 = xGEI - km </font>
            <br />
            <font face="ARIAL, HELVETICA">e2 = yGEI - km</font> 
            <br />
            <font face="ARIAL, HELVETICA">e3 = zGEI - km</font> 
            <br />
            <font face="ARIAL, HELVETICA">e4 = VxGEI - km/s</font> 
            <br />
            <font face="ARIAL, HELVETICA">e5 = VyGEI - km/s</font> 
            <br />
            <font face="ARIAL, HELVETICA">e6 = VzGEI - km/s</font> 
            <br />
        </div>
        <br />
        <font face="ARIAL, HELVETICA">4:&nbsp;SOLAR type elements:</font>&nbsp;<br />
        <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">e1 = inclination - deg </font>
            <br />
            <font face="ARIAL, HELVETICA">e2 = geocentric altitude of perigee - km</font> 
            <br />
            <font face="ARIAL, HELVETICA">e3 = geocentric altitude of apogee - km</font> 
            <br />
            <font face="ARIAL, HELVETICA">e4 = local time of apogee - hours</font> 
            <br />
            <font face="ARIAL, HELVETICA">e5 = local time of maximum inclination - hours</font> 
            <br />
            <font face="ARIAL, HELVETICA">Case options(3rd element) of:</font> 
            <br />
            <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">1:&nbsp;e6 = time since
                perigee passage - sec</font> 
                <br />
                <font face="ARIAL, HELVETICA">2:&nbsp;e6 = true anomaly at epoch - deg</font> 
                <br />
                <font face="ARIAL, HELVETICA">3:&nbsp;e6 = argument of latitude at epoch - deg</font> 
                <br />
                <font face="ARIAL, HELVETICA">4:&nbsp;e6 = true longitude at epoch - deg</font> 
                <br />
                <font face="ARIAL, HELVETICA">5:&nbsp;e6 = mean anomaly at epoch - deg</font> 
                <br />
            </div>
            <br />
        </div>
        <font face="ARIAL, HELVETICA">5:&nbsp;MEAN type elements:&nbsp;</font> 
        <br />
        <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">e1 = mean motion - rev/day </font>
            <br />
            <font face="ARIAL, HELVETICA">e2 = eccentricity</font> 
            <br />
            <font face="ARIAL, HELVETICA">e3 = inclination - deg</font> 
            <br />
            <font face="ARIAL, HELVETICA">e4 = longitude of the ascending node - deg</font> 
            <br />
            <font face="ARIAL, HELVETICA">Case options(2nd element) of:</font> 
            <br />
            <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">1:&nbsp;e5 = argument
                of perigee - deg</font> 
                <br />
                <font face="ARIAL, HELVETICA">2:&nbsp;e5 = longitude of perigee - deg</font> 
                <br />
            </div>
            <font face="ARIAL, HELVETICA">Case options(3rd element) of:</font> 
            <br />
            <div style="MARGIN-LEFT: 40px"><font face="ARIAL, HELVETICA">1:&nbsp;e6 = time since
                perigee passage - sec</font> 
                <br />
                <font face="ARIAL, HELVETICA">2:&nbsp;e6 = true anomaly at epoch - deg</font> 
                <br />
                <font face="ARIAL, HELVETICA">3:&nbsp;e6 = argument of latitude at epoch - deg</font> 
                <br />
                <font face="ARIAL, HELVETICA">4:&nbsp;e6 = true longitude at epoch - deg</font> 
                <br />
                <font face="ARIAL, HELVETICA">5:&nbsp;e6 = mean anomaly at epoch - deg</font> 
                <br />
            </div>
        </div>
    </div>
    <br />
    <p>
        <font face="ARIAL, HELVETICA"><b>startsfe:</b> double giving start time in seconds
        from date provided before. This number can be negative.</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><strong>stopsfe:</strong> double giving stop time in
        seconds from date provided before. This number can be negative. </font>
        <br />
        <br />
        <font face="ARIAL, HELVETICA"><strong>deltasec:</strong> double giving&nbsp;step time
        in seconds to produce orbit outputs. </font>
    </p>
    <p>
    </p>
    <p>
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>OUTyear:</b>&nbsp;array of long integer(GET_IRBEM_NTIME_MAX())&nbsp;giving
        output year for each orbital locations</font> 
        <br />
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>OUTdoy:</b>&nbsp;array of long integer(GET_IRBEM_NTIME_MAX())&nbsp;giving
        output&nbsp;day of year&nbsp;for each orbital locations</font> 
        <br />
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>UT:</b>&nbsp;array of double(GET_IRBEM_NTIME_MAX())&nbsp;giving
        output&nbsp;UT (seconds)&nbsp;for each orbital locations</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>X1:</b>&nbsp;array of double(GET_IRBEM_NTIME_MAX())&nbsp;giving
        first coordinate of orbit according to sysaxes</font> 
        <br />
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>X2:</b>&nbsp;array of double(GET_IRBEM_NTIME_MAX())&nbsp;giving&nbsp;second
        coordinate of orbit according to sysaxes</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>X3:</b>&nbsp;array of double(GET_IRBEM_NTIME_MAX())&nbsp;giving&nbsp;third
        coordinate of orbit according to sysaxes</font> 
        <br />
    </p>
    <p>
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">pos =&nbsp;onera_desp_lib_sgp4_ele([e1,e2,e3,e4,e5,e6],startdate,enddate,deltasec,sysaxesOUT)</font>&nbsp;<br />
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'sgp4_ele_', sysaxesOUT,year,month,day,hour,minute,sec,
        e1,e2,e3,e4,e5,e6,options,startsfe,stopsfe,deltasec,OUTyear,OUTdoy,UT,X1,X2,X3, /f_value)</font> 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">CALL </font><font face="ARIAL, HELVETICA">sgp4_ele1</font><font face="ARIAL, HELVETICA">(</font><font face="ARIAL, HELVETICA">sysaxesOUT,year,month,day,hour,minute,sec,
        e1,e2,e3,e4,e5,e6,options,startsfe,stopsfe,deltasec,OUTyear,OUTdoy,UT,X1,X2,X3</font><font face="ARIAL, HELVETICA">)<br />
        <br />
        </font>
        <br />
    </p>
    &nbsp;<hr><a name="RV2COE"></a> 
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">RV2COE</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">This function finds the classical orbital elements given
        the Geocentric Equatorial Position and Velocity vectors. It comes from SGP4 distribution.
        SGP4 stands for Simplified General Perturbation -4 and consists in an orbit propagator.
        More about SGP4 can be found at: <a href="http://celestrak.com/NORAD/documentation/spacetrk.pdf">http://celestrak.com/NORAD/documentation/spacetrk.pdf</a> and
        at <a href="http://www.centerforspace.com/downloads/files/pubs/AIAA 2006-6753 Revisiting Spacetrack Report 3.pdf">http://www.centerforspace.com/downloads/files/pubs/AIAA
        2006-6753 Revisiting Spacetrack Report 3.pdf</a></font> 
    </p>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"></font>
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>R:</b> array(3) of double. Position vector in GEI
        (km)</font>&nbsp; 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>V:</b> array(3) of double.&nbsp;Velocity vector in
        GEI (km/s)</font>. 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>P:</b>&nbsp;double. SemiLatus rectum (km)</font>&nbsp;<br />
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>A:</b>&nbsp;double. Semimajor&nbsp;axis (km)</font>&nbsp; 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>Ecc:</b>&nbsp;double.&nbsp;Eccentricity</font>&nbsp;<br />
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>Incl:</b>&nbsp;double.&nbsp;Inclination (rad)</font>&nbsp; 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>Omega:</b>&nbsp;double.&nbsp;Longitude of ascending
        node (rad)</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>Argp:</b>&nbsp;double.&nbsp;Argument of perigee (rad)</font>&nbsp; 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>Nu:</b>&nbsp;double.&nbsp;True anomaly (rad)</font>&nbsp; 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>M:</b>&nbsp;double.&nbsp;Mean anomaly (rad)</font>&nbsp; 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>ArgLat:</b>&nbsp;double.&nbsp;Argument of latitude
        (rad)</font> 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>LamTrue:</b>&nbsp;double.&nbsp;True longitude (rad)</font>&nbsp; 
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>LonPer:</b>&nbsp;double.&nbsp;Longitude of Periapsis
        (rad)</font>&nbsp;<br />
    </p>
    <p>
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <p>
        <font face="Arial">elements=onera_desp_lib_rv2coe(R,V)</font>&nbsp;<br />
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'rv2coe_idl_', R,V,P,A,Ecc,Incl,Omega,Argp,Nu,M,ArgLat,LamTrue,LonPer,
        /f_value)</font> 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">CALL </font><font face="ARIAL, HELVETICA">rv2coe</font><font face="ARIAL, HELVETICA">(</font><font face="ARIAL, HELVETICA">R,V,P,A,Ecc,Incl,Omega,Argp,Nu,M,ArgLat,LamTrue,LonPer</font><font face="ARIAL, HELVETICA">)<br />
        <br />
        </font>
        <br />
    </p>
    &nbsp; 
    <div>
    </div>
    <p>
    </p>

    <p>
        <br />
        <hr><a name="IRBEM_FORTRAN_VERSION"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">IRBEM_FORTRAN_VERSION</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Provides the repository version number of the fortran source code.</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>NONE</b></font> 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>VERSN</b> Repository version number (long integer).</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">VERSN = onera_desp_lib_fortran_version</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'irbem_fortran_version_',versn, /f_value)</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call IRBEM_FORTRAN_VERSION1(VERSN)</font> 
    <p>
        <br />
        <hr><a name="IRBEM_FORTRAN_RELEASE"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">IRBEM_FORTRAN_RELEASE</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Provides the repository release tag of the fortran source code.</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>NONE</b></font> 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>RLS</b> Repository release tag (character(80)).</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">RLS = onera_desp_lib_fortran_release</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'irbem_fortran_release_', rls, /f_value)</font><br />
    <b>Tip</b>: In IDL, string arguments should be defined as byte arrays, i.e.:
    &nbsp;&nbsp; <code>rls = BYTARR(80)</code>
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call IRBEM_FORTRAN_RELEASE1(RLS)</font> 
    <p>
        <br />
        <hr><a name="GET_IRBEM_NTIME_MAX"></a> 
    </p>
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">GET_IRBEM_NTIME_MAX</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">Returns size of time dimension in preallocated fortran arrays.</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>NONE</b></font> 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA"><b>NTIME_MAX</b>Time dimension size (long integer).</font> 
    <br />
    &nbsp; 
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">ntime_max = onera_desp_lib_ntime_max</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM IDL:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'get_irbem_ntime_max_',ntime_max, /f_value)</font> 
    <br />
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <font face="ARIAL, HELVETICA">call GET_IRBEM_NTIME_MAX1(ntime_max1)</font> 
    <br />
    &nbsp;<hr><a name="SHIELDOSE2"></a> 
    <h2><font face="ARIAL, HELVETICA"><font color="#0000ff">SHIELDOSE2</font></font> 
    </h2>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">DESCRIPTION:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">SHIELDOSE2 [Seltzer, 1994] is a computer code for 
        space-shielding radiation dose calculations. It determines the absorbed dose as a 
        function of depth in aluminium shielding material of spacecraft, given the electron 
        and proton fluences encountered in orbit. The code makes use of precalculated, 
        mono-energetic depth-dose data for an isotropic, broad-beam fluence of radiation 
        incident on uniform aluminium plane media. Such data are particularly suitable for 
        routine dose predictions in situations where the geometrical and compositional 
        complexities of the spacecraft are not known. Furthermore, the restriction to these 
        rather simple geometries has allowed for the development of accurate electron and 
        electron-bremsstrahlung data sets based on detailed transport calculations rather 
        than on more approximate methods.<BR>
        SHIELDOSE2 calculates, for arbitrary proton and electron incident spectra, 
        the dose absorbed in small volumes of different detector materials for the 
        following aluminium shield geometries:
        <ol>
        <li>
        in a semi-infinite plane medium, as a function of depth; irradiation is from one side only (the assumed infinite backing effectively insures this).
        </li>
        <li>
        at the transmission surface of a plane slab, as a function of slab thickness; irradiation is from one side only.
        </li>
        <li>
        at the centre of a solid sphere, as a function of sphere radius; irradiation is from all directions.     </p>
        </li>
        </ol>
    <p>
    </p>
    <p>
        <font face="ARIAL, HELVETICA"></font>
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">INPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>IDET:</b> long integer to set the index of the detector type:
        <ol>
        <li> Al detector </li>
        <li> Graphite detector </li>
        <li> Si detector </li>
        <li> Air detector </li>
        <li> Bone detector </li>
        <li> Calcium Fluoride detector </li>
        <li> Gallium Arsenide detector </li>
        <li> Lithium Fluoride detector </li>
        <li> Silicon Dioxide detector </li>
        <li> Tissue detector </li>
        <li> Water detector </li>
        </ol>
        </font>
        <font face="ARIAL, HELVETICA"><b>INUC:</b> long integer to indicate the nuclear interaction to account for:
        <ol>
        <li> No nuclear attenuation for protons in Al </li>
        <li> Nuclear attenuation, local charged-secondary energy deposition </li>
        <li> Nuclear attenuation, local charged-secondary energy deposition, and approx exponential distribution of neutron dose </li>
        </ol>
        </font> 
        <font face="ARIAL, HELVETICA"><b>IMAX:</b> long integer to set the number of shielding depth (max allowed=71). It is recommended to set this number close to maximum allowed value to compute accurate doses in semi-infinite aluminium medium and at center of aluminium spheres.
        </font>
        <br><br>
        <font face="ARIAL, HELVETICA"><b>IUNT:</b> long integer to set the shielding depth unit
        <ol>
        <li> Mils </li>
        <li> g/cm<sup>2</sup> </li>
        <li> mm </li>
        </ol>
        </font>
        <font face="ARIAL, HELVETICA"><b>Zin:</b> double array(71) of thickness in unit of IUNT. Below is provided a reasonable thickness array in g/cm<sup>2</sup> with IMAX=70<br>
  data Zin /1.000E-06,2.000E-06,5.000E-06,1.000E-05,2.000E-05,5.000E-05,1.000E-04,2.000E-04,&<br>
            5.000E-04,1.000E-03,1.000E-01,2.000E-01,5.000E-01,7.000E-01,1.000E+00,1.250E+00,&<br>
            1.500E+00,1.750E+00,2.000E+00,2.500E+00,3.000E+00,3.500E+00,4.000E+00,4.500E+00,&<br>
            5.000E+00,6.000E+00,7.000E+00,8.000E+00,9.000E+00,1.000E+01,1.100E+01,1.200E+01,&<br>
            1.300E+01,1.400E+01,1.500E+01,1.600E+01,1.700E+01,1.800E+01,1.900E+01,2.000E+01,&<br>
            2.100E+01,2.200E+01,2.300E+01,2.400E+01,2.500E+01,2.600E+01,2.700E+01,2.800E+01,&<br>
            2.900E+01,3.000E+01,3.100E+01,3.200E+01,3.300E+01,3.400E+01,3.500E+01,3.600E+01,&<br>
            3.700E+01,3.800E+01,3.900E+01,4.000E+01,4.100E+01,4.200E+01,4.300E+01,4.400E+01,&<br>
            4.500E+01,4.600E+01,4.700E+01,4.800E+01,4.900E+01,5.000E+01,0.000E+00/
        </font>
        <br><br>
        <font face="ARIAL, HELVETICA"><b>EminS:</b> min energy of solar protons spectrum (double) [MeV]
        </font>
        <br><br>
        <font face="ARIAL, HELVETICA"><b>EmaxS:</b> max energy of solar protons spectrum (double) [MeV]
        </font>
        <br><br>
        <font face="ARIAL, HELVETICA"><b>EminP:</b> min energy of trapped protons spectrum (double) [MeV]
        </font>
        <br><br>
        <font face="ARIAL, HELVETICA"><b>EmaxP:</b> max energy of trapped protons spectrum (double) [MeV]
        </font>
        <br><br>
        <font face="ARIAL, HELVETICA"><b>NPTSP:</b> number of spectrum points which divides proton spectra for integration. A value of 1001 is recommended (long integer).
        </font>
        <br><br>
        <font face="ARIAL, HELVETICA"><b>EminE:</b> min energy of trapped electrons spectrum (double) [MeV]
        </font>
        <br><br>
        <font face="ARIAL, HELVETICA"><b>EmaxE:</b> max energy of trapped electrons spectrum (double) [MeV]
        </font>
        <br><br>
        <font face="ARIAL, HELVETICA"><b>NPTSE:</b> Number of spectrum points which divides electron spectra for integration. A value of 1001 is recommended (long integer).
        </font>
        <br><br>
        <font face="ARIAL, HELVETICA"><b>JSMAX:</b> Number of points in falling spectrum of solar protons, max allowed=301 (long integer).
        </font>
        <br><br>
        <font face="ARIAL, HELVETICA"><b>JPMAX:</b> Number of points in falling spectrum of trapped protons, max allowed=301 (long integer).
        </font>
        <br><br>
        <font face="ARIAL, HELVETICA"><b>JEMAX:</b> Number of points in falling spectrum of trapped electrons, max allowed=301 (long integer).
        </font>
        <br><br>
        <font face="ARIAL, HELVETICA"><b>EUNIT:</b> Conversion factor from /energy to /MeV; e.g. EUNIT = 1000 if flux is /keV (double).
        </font>
        <br><br>
        <font face="ARIAL, HELVETICA"><b>DURATN:</b> Mission duration in multiples of unit time [s] (double).
        </font>
        <br><br>
        <font face="ARIAL, HELVETICA"><b>ESin:</b> Energy array(301) of solar proton spectrum [MeV] (double).
        </font>
        <br><br>
        <font face="ARIAL, HELVETICA"><b>SFLUXin:</b> Solar flare flux array(301) for solar protons [in /energy/cm<sup>2</sup>] (double).
        </font>
        <br><br>
        <font face="ARIAL, HELVETICA"><b>EPin:</b> Energy array(301) of trapped proton spectrum [MeV] (double).
        </font>
        <br><br>
        <font face="ARIAL, HELVETICA"><b>PFLUXin:</b> Incident omnidirectional flux array(301) for trapped protons [in /energy/cm<sup>2</sup>/s] (double).
        </font>
        <br><br>
        <font face="ARIAL, HELVETICA"><b>EEin:</b> Energy array(301) of trapped electron spectrum [MeV] (double).
        </font>
        <br><br>
        <font face="ARIAL, HELVETICA"><b>EFLUXin:</b> Incident omnidirectional flux array(301) for trapped electrons [in /energy/cm<sup>2</sup>/s] (double).
        </font>
        <br><br>
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">OUTPUTS:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA"><b>SolDose:</b>&nbsp;Dose profile array (71,3) for solar protons [rads] (double)
        <ol>
        <li> Dose in semi-infinite aluminium medium</li>
        <li> Dose at transmission surface of finite aluminium slab shields</li>
        <li> 1/2 Dose at center of aluminium spheres</li>
        </ol>
        </font><br />
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>ProtDose:</b>&nbsp;Dose profile array (71,3) for trapped protons [rads] (double)
        <ol>
        <li> Dose in semi-infinite aluminium medium</li>
        <li> Dose at transmission surface of finite aluminium slab shields</li>
        <li> 1/2 Dose at center of aluminium spheres</li>
        </ol>
        </font><br />
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>ElecDose:</b>&nbsp;Dose profile array (71,3) for trapped electrons [rads] (double)
        <ol>
        <li> Dose in semi-infinite aluminium medium</li>
        <li> Dose at transmission surface of finite aluminium slab shields</li>
        <li> 1/2 Dose at center of aluminium spheres</li>
        </ol>
        </font><br />
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>BremDose:</b>&nbsp;Dose profile array (71,3) for Bremsstrahlung [rads] (double)
        <ol>
        <li> Dose in semi-infinite aluminium medium</li>
        <li> Dose at transmission surface of finite aluminium slab shields</li>
        <li> 1/2 Dose at center of aluminium spheres</li>
        </ol>
        </font><br />
    </p>
    <p>
        <font face="ARIAL, HELVETICA"><b>TotDose:</b>&nbsp;Total dose profile array (71,3) [rads] (double) 
        <ol>
        <li> Dose in semi-infinite aluminium medium</li>
        <li> Dose at transmission surface of finite aluminium slab shields</li>
        <li> 1/2 Dose at center of aluminium spheres</li>
        </ol>
        </font><br />
    </p>
    <p>
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE FROM MATLAB:</font></font> 
    </h3>
    <p>
        <font face="Arial">
	  [ProtDose,ElecDose,BremDose,SolDose,TotDose] = onera_desp_lib_shieldose2(ProtSpect,ElecSpect,SolSpect,Target,...)
	</font>&nbsp;<br />
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from IDL:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">result = call_external(lib_name, 'shieldose2idl_', IDET,INUC,IMAX,IUNT,Zin,EMINS,EMAXS,EMINP,EMAXP,NPTSP,EMINE,EMAXE,NPTSE,JSMAX,JPMAX,JEMAX,EUNIT,DURATN,ESin,SFLUXin,EPin,PFLUXin,EEin,EFLUXin,SolDose,ProtDose,ElecDose,BremDose,TotDose,/f_value)</font> 
    </p>
    <h3><font face="ARIAL, HELVETICA"><font color="#ff0000">CALLING SEQUENCE from FORTRAN:</font></font> 
    </h3>
    <p>
        <font face="ARIAL, HELVETICA">CALL shieldose2(IDET,INUC,IMAX,IUNT,Zin,EMINS,EMAXS,EMINP,EMAXP,NPTSP,EMINE,EMAXE,NPTSE,JSMAX,JPMAX,JEMAX,EUNIT,DURATN,ESin,SFLUXin,EPin,PFLUXin,EEin,EFLUXin,SolDose,ProtDose,ElecDose,BremDose,TotDose)</font><br />
    </p>
    &nbsp; 
</body>
</html>

